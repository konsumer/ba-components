{
  "Action": {
    "args": [
      {
        "comment": "the trigger, with or without parameters, for the action",
        "name": "triggerOptions",
        "type": "Any"
      },
      {
        "name": "condition",
        "type": "Condition"
      }
    ],
    "comment": "The action to be carried out following a trigger",
    "family": "actions",
    "name": "Action",
    "props": [
      {
        "comment": "the trigger, with or without parameters, for the action",
        "name": "triggerOptions",
        "type": "Any"
      },
      {
        "comment": "Trigger for the action",
        "name": "trigger",
        "type": "Number"
      },
      {
        "comment": "An event triggered prior to action being executed.",
        "name": "onBeforeExecuteObservable",
        "type": "Observable"
      }
    ]
  },
  "ActionEvent": {
    "args": [
      {
        "comment": "The mesh or sprite that triggered the action",
        "name": "source",
        "type": "Any"
      },
      {
        "comment": "The X mouse cursor position at the time of the event",
        "name": "pointerX",
        "type": "Number"
      },
      {
        "comment": "The Y mouse cursor position at the time of the event",
        "name": "pointerY",
        "type": "Number"
      },
      {
        "comment": "The mesh that is currently pointed at (can be null)",
        "name": "meshUnderPointer",
        "type": "Nullable"
      },
      {
        "comment": "the original (browser) event that triggered the ActionEvent",
        "name": "sourceEvent",
        "type": "Any"
      },
      {
        "comment": "additional data for the event",
        "name": "additionalData",
        "type": "Any"
      }
    ],
    "comment": "ActionEvent is the event being sent when an action is triggered.",
    "family": "actions",
    "name": "ActionEvent",
    "props": [
      {
        "comment": "The mesh or sprite that triggered the action",
        "name": "source",
        "type": "Any"
      },
      {
        "comment": "The X mouse cursor position at the time of the event",
        "name": "pointerX",
        "type": "Number"
      },
      {
        "comment": "The Y mouse cursor position at the time of the event",
        "name": "pointerY",
        "type": "Number"
      },
      {
        "comment": "The mesh that is currently pointed at (can be null)",
        "name": "meshUnderPointer",
        "type": "Nullable"
      },
      {
        "comment": "the original (browser) event that triggered the ActionEvent",
        "name": "sourceEvent",
        "type": "Any"
      },
      {
        "comment": "additional data for the event",
        "name": "additionalData",
        "type": "Any"
      }
    ]
  },
  "ActionManager": {
    "args": [
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Action Manager manages all events to be triggered on a given mesh or the global scene.\nA single scene can have many Action Managers to handle predefined actions on specific meshes.",
    "family": "actions",
    "name": "ActionManager",
    "props": [
      {
        "comment": "Gets the list of actions",
        "name": "actions",
        "type": [
          "Action"
        ]
      },
      {
        "comment": "Gets the cursor to use when hovering items",
        "name": "hoverCursor",
        "type": "String"
      },
      {
        "comment": "Does this action manager has pointer triggers",
        "name": "hasPointerTriggers",
        "type": "Boolean"
      },
      {
        "comment": "Does this action manager has pick triggers",
        "name": "hasPickTriggers",
        "type": "Boolean"
      }
    ]
  },
  "AnaglyphArcRotateCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "alpha",
        "type": "Number"
      },
      {
        "name": "beta",
        "type": "Number"
      },
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)",
    "family": "cameras",
    "name": "AnaglyphArcRotateCamera",
    "props": []
  },
  "AnaglyphFreeCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate anaglyphic rendering (based on FreeCamera)",
    "family": "cameras",
    "name": "AnaglyphFreeCamera",
    "props": []
  },
  "AnaglyphGamepadCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate anaglyphic rendering (based on GamepadCamera)",
    "family": "cameras",
    "name": "AnaglyphGamepadCamera",
    "props": []
  },
  "AnaglyphUniversalCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate anaglyphic rendering (based on UniversalCamera)",
    "family": "cameras",
    "name": "AnaglyphUniversalCamera",
    "props": []
  },
  "ArcFollowCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "comment": "The longitudinal angle of the camera",
        "name": "alpha",
        "type": "Number"
      },
      {
        "comment": "The latitudinal angle of the camera",
        "name": "beta",
        "type": "Number"
      },
      {
        "comment": "The radius of the camera from its target",
        "name": "radius",
        "type": "Number"
      },
      {
        "comment": "Define the camera target (the messh it should follow)",
        "name": "target",
        "type": "Nullable"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Arc Rotate version of the follow camera.\nIt still follows a Defined mesh but in an Arc Rotate Camera fashion.",
    "family": "cameras",
    "name": "ArcFollowCamera",
    "props": [
      {
        "comment": "The longitudinal angle of the camera",
        "name": "alpha",
        "type": "Number"
      },
      {
        "comment": "The latitudinal angle of the camera",
        "name": "beta",
        "type": "Number"
      },
      {
        "comment": "The radius of the camera from its target",
        "name": "radius",
        "type": "Number"
      },
      {
        "comment": "Define the camera target (the messh it should follow)",
        "name": "target",
        "type": "Nullable"
      }
    ]
  },
  "ArcRotateCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "alpha",
        "type": "Number"
      },
      {
        "name": "beta",
        "type": "Number"
      },
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "setActiveOnSceneIfNoneActive",
        "type": "Boolean"
      }
    ],
    "comment": "This represents an orbital type of camera.\n\nThis camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\nThink of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.",
    "family": "cameras",
    "name": "ArcRotateCamera",
    "props": [
      {
        "comment": "Defines the rotation angle of the camera along the longitudinal axis.",
        "name": "alpha",
        "type": "Number"
      },
      {
        "comment": "Defines the rotation angle of the camera along the latitudinal axis.",
        "name": "beta",
        "type": "Number"
      },
      {
        "comment": "Defines the radius of the camera from it s target point.",
        "name": "radius",
        "type": "Number"
      },
      {
        "comment": "Defines the target point of the camera.\nThe camera looks towards it form the radius distance.",
        "name": "target",
        "type": "Vector3"
      },
      {
        "comment": "Current inertia value on the longitudinal axis.\nThe bigger this number the longer it will take for the camera to stop.",
        "name": "inertialAlphaOffset",
        "type": "Number"
      },
      {
        "comment": "Current inertia value on the latitudinal axis.\nThe bigger this number the longer it will take for the camera to stop.",
        "name": "inertialBetaOffset",
        "type": "Number"
      },
      {
        "comment": "Current inertia value on the radius axis.\nThe bigger this number the longer it will take for the camera to stop.",
        "name": "inertialRadiusOffset",
        "type": "Number"
      },
      {
        "comment": "Minimum allowed angle on the longitudinal axis.\nThis can help limiting how the Camera is able to move in the scene.",
        "name": "lowerAlphaLimit",
        "type": "Nullable"
      },
      {
        "comment": "Maximum allowed angle on the longitudinal axis.\nThis can help limiting how the Camera is able to move in the scene.",
        "name": "upperAlphaLimit",
        "type": "Nullable"
      },
      {
        "comment": "Minimum allowed angle on the latitudinal axis.\nThis can help limiting how the Camera is able to move in the scene.",
        "name": "lowerBetaLimit",
        "type": "Number"
      },
      {
        "comment": "Maximum allowed angle on the latitudinal axis.\nThis can help limiting how the Camera is able to move in the scene.",
        "name": "upperBetaLimit",
        "type": "Number"
      },
      {
        "comment": "Minimum allowed distance of the camera to the target (The camera can not get closer).\nThis can help limiting how the Camera is able to move in the scene.",
        "name": "lowerRadiusLimit",
        "type": "Nullable"
      },
      {
        "comment": "Maximum allowed distance of the camera to the target (The camera can not get further).\nThis can help limiting how the Camera is able to move in the scene.",
        "name": "upperRadiusLimit",
        "type": "Nullable"
      },
      {
        "comment": "Defines the current inertia value used during panning of the camera along the X axis.",
        "name": "inertialPanningX",
        "type": "Number"
      },
      {
        "comment": "Defines the current inertia value used during panning of the camera along the Y axis.",
        "name": "inertialPanningY",
        "type": "Number"
      },
      {
        "comment": "Defines the distance used to consider the camera in pan mode vs pinch/zoom.\nBasically if your fingers moves away from more than this distance you will be considered\nin pinch mode.",
        "name": "pinchToPanMaxDistance",
        "type": "Number"
      },
      {
        "comment": "Defines the maximum distance the camera can pan.\nThis could help keeping the cammera always in your scene.",
        "name": "panningDistanceLimit",
        "type": "Nullable"
      },
      {
        "comment": "Defines the target of the camera before paning.",
        "name": "panningOriginTarget",
        "type": "Vector3"
      },
      {
        "comment": "Defines the value of the inertia used during panning.\n0 would mean stop inertia and one would mean no decelleration at all.",
        "name": "panningInertia",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.",
        "name": "angularSensibilityX",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.",
        "name": "angularSensibilityY",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the pointer pinch precision or how fast is the camera zooming.",
        "name": "pinchPrecision",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\nIt will be used instead of pinchDeltaPrecision if different from 0.\nIt defines the percentage of current camera.radius to use as delta when pinch zoom is used.",
        "name": "pinchDeltaPercentage",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the pointer panning sensibility or how fast is the camera moving.",
        "name": "panningSensibility",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control beta angle in a positive direction.",
        "name": "keysUp",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control beta angle in a negative direction.",
        "name": "keysDown",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.",
        "name": "keysLeft",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.",
        "name": "keysRight",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Gets or Set the mouse wheel precision or how fast is the camera zooming.",
        "name": "wheelPrecision",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\nIt will be used instead of pinchDeltaPrecision if different from 0.\nIt defines the percentage of current camera.radius to use as delta when pinch zoom is used.",
        "name": "wheelDeltaPercentage",
        "type": "Number"
      },
      {
        "comment": "Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)",
        "name": "zoomOnFactor",
        "type": "Number"
      },
      {
        "comment": "Defines a screen offset for the camera position.",
        "name": "targetScreenOffset",
        "type": "Vector2"
      },
      {
        "comment": "Allows the camera to be completely reversed.\nIf false the camera can not arrive upside down.",
        "name": "allowUpsideDown",
        "type": "Boolean"
      },
      {
        "comment": "Define if double tap/click is used to restore the previously saved state of the camera.",
        "name": "useInputToRestoreState",
        "type": "Boolean"
      },
      {
        "comment": "Defines the inpute associated to the camera.",
        "name": "inputs",
        "type": "ArcRotateCameraInputsManager"
      },
      {
        "comment": "Defines the allowed panning axis.",
        "name": "panningAxis",
        "type": "Vector3"
      },
      {
        "comment": "Gets the bouncing behavior of the camera if it has been enabled.",
        "name": "bouncingBehavior",
        "type": "Nullable"
      },
      {
        "comment": "Defines if the bouncing behavior of the camera is enabled on the camera.",
        "name": "useBouncingBehavior",
        "type": "Boolean"
      },
      {
        "comment": "Gets the framing behavior of the camera if it has been enabled.",
        "name": "framingBehavior",
        "type": "Nullable"
      },
      {
        "comment": "Defines if the framing behavior of the camera is enabled on the camera.",
        "name": "useFramingBehavior",
        "type": "Boolean"
      },
      {
        "comment": "Gets the auto rotation behavior of the camera if it has been enabled.",
        "name": "autoRotationBehavior",
        "type": "Nullable"
      },
      {
        "comment": "Defines if the auto rotation behavior of the camera is enabled on the camera.",
        "name": "useAutoRotationBehavior",
        "type": "Boolean"
      },
      {
        "comment": "Observable triggered when the mesh target has been changed on the camera.",
        "name": "onMeshTargetChangedObservable",
        "type": "Observable"
      },
      {
        "comment": "Event raised when the camera is colliding with a mesh.",
        "name": "onCollide",
        "type": "Function"
      },
      {
        "comment": "Defines whether the camera should check collision with the objects oh the scene.",
        "name": "checkCollisions",
        "type": "Boolean"
      },
      {
        "comment": "Defines the collision radius of the camera.\nThis simulates a sphere around the camera.",
        "name": "collisionRadius",
        "type": "Vector3"
      }
    ]
  },
  "BackgroundMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Background material used to create an efficient environement around your scene.",
    "family": "materials",
    "name": "BackgroundMaterial",
    "props": [
      {
        "comment": "Key light Color (multiply against the environement texture)",
        "name": "primaryColor",
        "type": "Color3"
      },
      {
        "comment": "Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.\nThe color opposite to the primary color is used at the level chosen to define what the black area would look.",
        "name": "primaryColorShadowLevel",
        "type": "float"
      },
      {
        "comment": "Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.\nThe primary color is used at the level chosen to define what the white area would look.",
        "name": "primaryColorHighlightLevel",
        "type": "float"
      },
      {
        "comment": "Reflection Texture used in the material.\nShould be author in a specific way for the best result (refer to the documentation).",
        "name": "reflectionTexture",
        "type": "Nullable"
      },
      {
        "comment": "Reflection Texture level of blur.\n\nCan be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the\ntexture twice.",
        "name": "reflectionBlur",
        "type": "float"
      },
      {
        "comment": "Diffuse Texture used in the material.\nShould be author in a specific way for the best result (refer to the documentation).",
        "name": "diffuseTexture",
        "type": "Nullable"
      },
      {
        "comment": "Specify the list of lights casting shadow on the material.\nAll scene shadow lights will be included if null.",
        "name": "shadowLights",
        "type": "Nullable"
      },
      {
        "comment": "Helps adjusting the shadow to a softer level if required.\n0 means black shadows and 1 means no shadows.",
        "name": "shadowLevel",
        "type": "float"
      },
      {
        "comment": "In case of opacity Fresnel or reflection falloff, this is use as a scene center.\nIt is usually zero but might be interesting to modify according to your setup.",
        "name": "sceneCenter",
        "type": "Vector3"
      },
      {
        "comment": "This helps specifying that the material is falling off to the sky box at grazing angle.\nThis helps ensuring a nice transition when the camera goes under the ground.",
        "name": "opacityFresnel",
        "type": "Boolean"
      },
      {
        "comment": "This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.\nThis helps adding a mirror texture on the ground.",
        "name": "reflectionFresnel",
        "type": "Boolean"
      },
      {
        "comment": "This helps specifying the falloff radius off the reflection texture from the sceneCenter.\nThis helps adding a nice falloff effect to the reflection if used as a mirror for instance.",
        "name": "reflectionFalloffDistance",
        "type": "Number"
      },
      {
        "comment": "This specifies the weight of the reflection against the background in case of reflection Fresnel.",
        "name": "reflectionAmount",
        "type": "Number"
      },
      {
        "comment": "This specifies the weight of the reflection at grazing angle.",
        "name": "reflectionReflectance0",
        "type": "Number"
      },
      {
        "comment": "This specifies the weight of the reflection at a perpendicular point of view.",
        "name": "reflectionReflectance90",
        "type": "Number"
      },
      {
        "comment": "Sets the reflection reflectance fresnel values according to the default standard\nempirically know to work well :-)",
        "name": "reflectionStandardFresnelWeight",
        "type": "Number"
      },
      {
        "comment": "Helps to directly use the maps channels instead of their level.",
        "name": "useRGBColor",
        "type": "Boolean"
      },
      {
        "comment": "This helps reducing the banding effect that could occur on the background.",
        "name": "enableNoise",
        "type": "Boolean"
      },
      {
        "comment": "The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\nBest used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.\nRecommended to be keep at 1.0 except for special cases.",
        "name": "fovMultiplier",
        "type": "Number"
      },
      {
        "comment": "Enable the FOV adjustment feature controlled by fovMultiplier.",
        "name": "useEquirectangularFOV",
        "type": "Boolean"
      },
      {
        "comment": "Number of Simultaneous lights allowed on the material.",
        "name": "maxSimultaneousLights",
        "type": "int"
      },
      {
        "comment": "Gets the image processing configuration used either in this material.",
        "name": "imageProcessingConfiguration",
        "type": "Nullable"
      },
      {
        "comment": "Gets wether the color curves effect is enabled.",
        "name": "cameraColorCurvesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets wether the color grading effect is enabled.",
        "name": "cameraColorGradingEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets wether tonemapping is enabled or not.",
        "name": "cameraToneMappingEnabled",
        "type": "Boolean"
      },
      {
        "comment": "The camera exposure used on this material.\nThis property is here and not in the camera to allow controlling exposure without full screen post process.\nThis corresponds to a photographic exposure.",
        "name": "cameraExposure",
        "type": "float"
      },
      {
        "comment": "Gets The camera contrast used on this material.",
        "name": "cameraContrast",
        "type": "float"
      },
      {
        "comment": "Gets the Color Grading 2D Lookup Texture.",
        "name": "cameraColorGradingTexture",
        "type": "Nullable"
      },
      {
        "comment": "The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\nThey allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\nThese are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\ncorresponding to low luminance, medium luminance, and high luminance areas respectively.",
        "name": "cameraColorCurves",
        "type": "Nullable"
      },
      {
        "comment": "Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.\nSetting this flag to true (not done automatically!) will convert it back to RGB.",
        "name": "switchToBGR",
        "type": "Boolean"
      },
      {
        "comment": "Gets a boolean indicating that current material needs to register RTT",
        "name": "hasRenderTargetTextures",
        "type": "Boolean"
      }
    ]
  },
  "BaseTexture": {
    "args": [
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Base class of all the textures in babylon.\nIt groups all the common properties the materials, post process, lights... might need\nin order to make a correct use of the texture.",
    "family": "materials",
    "name": "BaseTexture",
    "props": [
      {
        "comment": "Define the name of the texture.",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).",
        "name": "hasAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Defines if the alpha value should be determined via the rgb values.\nIf true the luminance of the pixel might be used to find the corresponding alpha value.",
        "name": "getAlphaFromRGB",
        "type": "Boolean"
      },
      {
        "comment": "Intensity or strength of the texture.\nIt is commonly used by materials to fine tune the intensity of the texture",
        "name": "level",
        "type": "Number"
      },
      {
        "comment": "Define the UV chanel to use starting from 0 and defaulting to 0.\nThis is part of the texture as textures usually maps to one uv set.",
        "name": "coordinatesIndex",
        "type": "Number"
      },
      {
        "comment": "How a texture is mapped.\n\n| Value | Type                                | Description |\n| ----- | ----------------------------------- | ----------- |\n| 0     | EXPLICIT_MODE                       |             |\n| 1     | SPHERICAL_MODE                      |             |\n| 2     | PLANAR_MODE                         |             |\n| 3     | CUBIC_MODE                          |             |\n| 4     | PROJECTION_MODE                     |             |\n| 5     | SKYBOX_MODE                         |             |\n| 6     | INVCUBIC_MODE                       |             |\n| 7     | EQUIRECTANGULAR_MODE                |             |\n| 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\n| 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |",
        "name": "coordinatesMode",
        "type": "Number"
      },
      {
        "comment": "| Value | Type               | Description |\n| ----- | ------------------ | ----------- |\n| 0     | CLAMP_ADDRESSMODE  |             |\n| 1     | WRAP_ADDRESSMODE   |             |\n| 2     | MIRROR_ADDRESSMODE |             |",
        "name": "wrapU",
        "type": "Number"
      },
      {
        "comment": "| Value | Type               | Description |\n| ----- | ------------------ | ----------- |\n| 0     | CLAMP_ADDRESSMODE  |             |\n| 1     | WRAP_ADDRESSMODE   |             |\n| 2     | MIRROR_ADDRESSMODE |             |",
        "name": "wrapV",
        "type": "Number"
      },
      {
        "comment": "| Value | Type               | Description |\n| ----- | ------------------ | ----------- |\n| 0     | CLAMP_ADDRESSMODE  |             |\n| 1     | WRAP_ADDRESSMODE   |             |\n| 2     | MIRROR_ADDRESSMODE |             |",
        "name": "wrapR",
        "type": "Number"
      },
      {
        "comment": "With compliant hardware and browser (supporting anisotropic filtering)\nthis defines the level of anisotropic filtering in the texture.\nThe higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.",
        "name": "anisotropicFilteringLevel",
        "type": "Number"
      },
      {
        "comment": "Define if the texture is a cube texture or if false a 2d texture.",
        "name": "isCube",
        "type": "Boolean"
      },
      {
        "comment": "Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.",
        "name": "is3D",
        "type": "Boolean"
      },
      {
        "comment": "Define if the texture contains data in gamma space (most of the png/jpg aside bump).\nHDR texture are usually stored in linear space.\nThis only impacts the PBR and Background materials",
        "name": "gammaSpace",
        "type": "Boolean"
      },
      {
        "comment": "Gets whether or not the texture contains RGBD data.",
        "name": "isRGBD",
        "type": "Boolean"
      },
      {
        "comment": "Is Z inverted in the texture (useful in a cube texture).",
        "name": "invertZ",
        "type": "Boolean"
      },
      {
        "name": "lodLevelInAlpha",
        "type": "Boolean"
      },
      {
        "comment": "With prefiltered texture, defined the offset used during the prefiltering steps.",
        "name": "lodGenerationOffset",
        "type": "Number"
      },
      {
        "comment": "With prefiltered texture, defined the scale used during the prefiltering steps.",
        "name": "lodGenerationScale",
        "type": "Number"
      },
      {
        "comment": "Define if the texture is a render target.",
        "name": "isRenderTarget",
        "type": "Boolean"
      },
      {
        "comment": "Define the unique id of the texture in the scene.",
        "name": "uid",
        "type": "String"
      },
      {
        "comment": "Define the list of animation attached to the texture.",
        "name": "animations",
        "type": [
          "Animation"
        ]
      },
      {
        "comment": "An event triggered when the texture is disposed.",
        "name": "onDisposeObservable",
        "type": "Observable"
      },
      {
        "comment": "Callback triggered when the texture has been disposed.\nKept for back compatibility, you can use the onDisposeObservable instead.",
        "name": "onDispose",
        "type": "Function"
      },
      {
        "comment": "Define the current state of the loading sequence when in delayed load mode.",
        "name": "delayLoadState",
        "type": "Number"
      },
      {
        "comment": "Define if the texture is preventinga material to render or not.\nIf not and the texture is not ready, the engine will use a default black texture instead.",
        "name": "isBlocking",
        "type": "Boolean"
      },
      {
        "comment": "Get if the texture can rescale.",
        "name": "canRescale",
        "type": "Boolean"
      },
      {
        "comment": "Get the texture underlying type (INT, FLOAT...)",
        "name": "textureType",
        "type": "Number"
      },
      {
        "comment": "Get the texture underlying format (RGB, RGBA...)",
        "name": "textureFormat",
        "type": "Number"
      },
      {
        "comment": "Get the polynomial representation of the texture data.\nThis is mainly use as a fast way to recover IBL Diffuse irradiance data.",
        "name": "sphericalPolynomial",
        "type": "Nullable"
      }
    ]
  },
  "Box": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a box mesh\n* The parameter `size` sets the size (float) of each box side (default 1)\n* You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\n* You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\n* Please read this tutorial : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateBox",
    "options": [
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "width",
        "type": "Number"
      },
      {
        "name": "height",
        "type": "Number"
      },
      {
        "name": "depth",
        "type": "Number"
      },
      {
        "name": "faceUV",
        "type": [
          "Vector4"
        ]
      },
      {
        "name": "faceColors",
        "type": [
          "Color4"
        ]
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "Camera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "setActiveOnSceneIfNoneActive",
        "type": "Boolean"
      }
    ],
    "comment": "This is the base class of all the camera used in the application.",
    "family": "cameras",
    "name": "Camera",
    "props": [
      {
        "comment": "Define the input manager associated with the camera.",
        "name": "inputs",
        "type": "CameraInputsManager"
      },
      {
        "comment": "Define the current local position of the camera in the scene",
        "name": "position",
        "type": "Vector3"
      },
      {
        "comment": "The vector the camera should consider as up.\n(default is Vector3(0, 1, 0) aka Vector3.Up())",
        "name": "upVector",
        "type": "Vector3"
      },
      {
        "comment": "Define the current limit on the left side for an orthographic camera\nIn scene unit",
        "name": "orthoLeft",
        "type": "Nullable"
      },
      {
        "comment": "Define the current limit on the right side for an orthographic camera\nIn scene unit",
        "name": "orthoRight",
        "type": "Nullable"
      },
      {
        "comment": "Define the current limit on the bottom side for an orthographic camera\nIn scene unit",
        "name": "orthoBottom",
        "type": "Nullable"
      },
      {
        "comment": "Define the current limit on the top side for an orthographic camera\nIn scene unit",
        "name": "orthoTop",
        "type": "Nullable"
      },
      {
        "comment": "Field Of View is set in Radians. (default is 0.8)",
        "name": "fov",
        "type": "Number"
      },
      {
        "comment": "Define the minimum distance the camera can see from.\nThis is important to note that the depth buffer are not infinite and the closer it starts\nthe more your scene might encounter depth fighting issue.",
        "name": "minZ",
        "type": "Number"
      },
      {
        "comment": "Define the maximum distance the camera can see to.\nThis is important to note that the depth buffer are not infinite and the further it end\nthe more your scene might encounter depth fighting issue.",
        "name": "maxZ",
        "type": "Number"
      },
      {
        "comment": "Define the default inertia of the camera.\nThis helps giving a smooth feeling to the camera movement.",
        "name": "inertia",
        "type": "Number"
      },
      {
        "comment": "Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.PERSPECTIVE_ORTHOGRAPHIC)",
        "name": "mode",
        "type": "Number"
      },
      {
        "comment": "Define wether the camera is intermediate.\nThis is usefull to not present the output directly to the screen in case of rig without post process for instance",
        "name": "isIntermediate",
        "type": "Boolean"
      },
      {
        "comment": "Define the viewport of the camera.\nThis correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.",
        "name": "viewport",
        "type": "Viewport"
      },
      {
        "comment": "Restricts the camera to viewing objects with the same layerMask.\nA camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0",
        "name": "layerMask",
        "type": "Number"
      },
      {
        "comment": "fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)",
        "name": "fovMode",
        "type": "Number"
      },
      {
        "comment": "Rig mode of the camera.\nThis is usefull to create the camera with two \"eyes\" instead of one to create VR or stereoscopic scenes.\nThis is normally controlled byt the camera themselves as internal use.",
        "name": "cameraRigMode",
        "type": "Number"
      },
      {
        "comment": "Defines the distance between both \"eyes\" in case of a RIG",
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "comment": "Defines if stereoscopic rendering is done side by side or over under.",
        "name": "isStereoscopicSideBySide",
        "type": "Boolean"
      },
      {
        "comment": "Defines the list of custom render target the camera should render to.\nThis is pretty helpfull if you wish to make a camera render to a texture you could reuse somewhere\nelse in the scene.",
        "name": "customRenderTargets",
        "type": [
          "RenderTargetTexture"
        ]
      },
      {
        "comment": "Observable triggered when the camera view matrix has changed.",
        "name": "onViewMatrixChangedObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable triggered when the camera Projection matrix has changed.",
        "name": "onProjectionMatrixChangedObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable triggered when the inputs have been processed.",
        "name": "onAfterCheckInputsObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable triggered when reset has been called and applied to the camera.",
        "name": "onRestoreStateObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets the current world space position of the camera.",
        "name": "globalPosition",
        "type": "Vector3"
      },
      {
        "name": "rigCameras",
        "type": [
          "Camera"
        ]
      },
      {
        "comment": "Gets the post process used by the rig cameras",
        "name": "rigPostProcess",
        "type": "Nullable"
      },
      {
        "comment": "Gets the left camera of a rig setup in case of Rigged Camera",
        "name": "leftCamera",
        "type": "Nullable"
      },
      {
        "comment": "Gets the right camera of a rig setup in case of Rigged Camera",
        "name": "rightCamera",
        "type": "Nullable"
      }
    ]
  },
  "ColorGradingTexture": {
    "args": [
      {
        "name": "url",
        "type": "String"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "This represents a color grading texture. This acts as a lookup table LUT, useful during post process\nIt can help converting any input color in a desired output one. This can then be used to create effects\nfrom sepia, black and white to sixties or futuristic rendering...\n\nThe only supported format is currently 3dl.\nMore information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table",
    "family": "materials",
    "name": "ColorGradingTexture",
    "props": [
      {
        "comment": "The texture URL.",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Occurs when the file being loaded is a .3dl LUT file.",
        "name": "load3dlTexture"
      },
      {
        "comment": "Starts the loading process of the texture.",
        "name": "loadTexture"
      }
    ]
  },
  "CubeTexture": {
    "args": [
      {
        "name": "rootUrl",
        "type": "String"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "extensions",
        "type": "Nullable"
      },
      {
        "name": "noMipmap",
        "type": "Boolean"
      },
      {
        "name": "files",
        "type": "Nullable"
      },
      {
        "name": "onLoad",
        "type": "Nullable"
      },
      {
        "name": "onError",
        "type": "Nullable"
      },
      {
        "name": "format",
        "type": "Number"
      },
      {
        "name": "prefiltered",
        "type": "Boolean"
      },
      {
        "name": "forcedExtension",
        "type": "Any"
      },
      {
        "name": "createPolynomials",
        "type": "Boolean"
      },
      {
        "name": "lodScale",
        "type": "Number"
      },
      {
        "name": "lodOffset",
        "type": "Number"
      }
    ],
    "comment": "Class for creating a cube texture",
    "family": "materials",
    "name": "CubeTexture",
    "props": [
      {
        "comment": "The url of the texture",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Gets or sets the center of the bounding box associated with the cube texture.\nIt must define where the camera used to render the texture was set",
        "name": "boundingBoxPosition",
        "type": "Vector3"
      },
      {
        "comment": "Gets or sets the size of the bounding box associated with the cube texture\nWhen defined, the cubemap will switch to local mode",
        "name": "boundingBoxSize",
        "type": "Vector3"
      },
      {
        "comment": "Sets texture matrix rotation angle around Y axis in radians.",
        "name": "rotationY",
        "type": "Number"
      }
    ]
  },
  "CubeTextureAssetTask": {
    "args": [
      {
        "comment": "Defines the name of the task",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)",
        "name": "extensions",
        "type": "Union"
      },
      {
        "comment": "Defines if mipmaps should not be generated (default is false)",
        "name": "noMipmap",
        "type": "Union"
      },
      {
        "comment": "Defines the explicit list of files (undefined by default)",
        "name": "files",
        "type": "Union"
      }
    ],
    "comment": "Define a task used by AssetsManager to load cube textures",
    "family": "materials",
    "name": "CubeTextureAssetTask",
    "props": [
      {
        "comment": "Defines the name of the task",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)",
        "name": "extensions",
        "type": "Union"
      },
      {
        "comment": "Defines if mipmaps should not be generated (default is false)",
        "name": "noMipmap",
        "type": "Union"
      },
      {
        "comment": "Defines the explicit list of files (undefined by default)",
        "name": "files",
        "type": "Union"
      },
      {
        "comment": "Gets the loaded texture",
        "name": "texture",
        "type": "CubeTexture"
      },
      {
        "comment": "Callback called when the task is successful",
        "name": "onSuccess",
        "type": "Function"
      },
      {
        "comment": "Callback called when the task is successful",
        "name": "onError",
        "type": "Function"
      }
    ]
  },
  "CustomProceduralTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "texturePath",
        "type": "String"
      },
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "fallbackTexture",
        "type": "Texture"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      }
    ],
    "comment": "Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\nCustom Procedural textures are the easiest way to create your own procedural in your application.",
    "family": "materials",
    "name": "CustomProceduralTexture",
    "props": [
      {
        "comment": "Define if the texture animates or not.",
        "name": "animate",
        "type": "Boolean"
      }
    ]
  },
  "Cylinder": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a cylinder or a cone mesh\n* The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n* The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n* The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n* The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n* The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n* The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\n* The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\n* The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\n* You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\n* The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\n* Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\n* Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\n* Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\n* If `enclose` is false, a ring surface is one element.\n* If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\n* Example how to set colors and textures on a sliced cylinder : http://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.",
    "family": "meshes",
    "name": "CreateCylinder",
    "options": [
      {
        "name": "height",
        "type": "Number"
      },
      {
        "name": "diameterTop",
        "type": "Number"
      },
      {
        "name": "diameterBottom",
        "type": "Number"
      },
      {
        "name": "diameter",
        "type": "Number"
      },
      {
        "name": "tessellation",
        "type": "Number"
      },
      {
        "name": "subdivisions",
        "type": "Number"
      },
      {
        "name": "arc",
        "type": "Number"
      },
      {
        "name": "faceColors",
        "type": [
          "Color4"
        ]
      },
      {
        "name": "faceUV",
        "type": [
          "Vector4"
        ]
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "hasRings",
        "type": "Boolean"
      },
      {
        "name": "enclose",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "DashedLines": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a dashed line mesh\n* A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n* Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n* The parameter `points` is an array successive Vector3\n* The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\n* The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\n* The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\n* The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n* When updating an instance, remember that only point positions can change, not the number of points\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateDashedLines",
    "options": [
      {
        "name": "points",
        "type": [
          "Vector3"
        ]
      },
      {
        "name": "dashSize",
        "type": "Number"
      },
      {
        "name": "gapSize",
        "type": "Number"
      },
      {
        "name": "dashNb",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "instance",
        "type": "LinesMesh"
      }
    ],
    "props": [],
    "return": "LinesMesh"
  },
  "Decal": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "sourceMesh",
        "type": "AbstractMesh"
      }
    ],
    "comment": "Creates a decal mesh.\nA decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\n* The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\n* The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\n* The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\n* The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal",
    "family": "meshes",
    "name": "CreateDecal",
    "options": [
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "normal",
        "type": "Vector3"
      },
      {
        "name": "size",
        "type": "Vector3"
      },
      {
        "name": "angle",
        "type": "Number"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "DepthTextureCreationOptions": {
    "args": [],
    "comment": "Define options used to create a depth texture",
    "family": "materials",
    "name": "DepthTextureCreationOptions",
    "props": [
      {
        "comment": "Specifies whether or not a stencil should be allocated in the texture",
        "name": "generateStencil",
        "type": "Boolean"
      },
      {
        "comment": "Specifies whether or not bilinear filtering is enable on the texture",
        "name": "bilinearFiltering",
        "type": "Boolean"
      },
      {
        "comment": "Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode",
        "name": "comparisonFunction",
        "type": "Number"
      },
      {
        "comment": "Specifies if the created texture is a cube texture",
        "name": "isCube",
        "type": "Boolean"
      }
    ]
  },
  "DeviceOrientationCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "This is a camera specifically designed to react to device orientation events such as a modern mobile device\nbeing tilted forward or back and left or right.",
    "family": "cameras",
    "name": "DeviceOrientationCamera",
    "props": []
  },
  "DirectionalLight": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "direction",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "A directional light is defined by a direction (what a surprise!).\nThe light is emitted from everywhere in the specified direction, and has an infinite range.\nAn example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\nDocumentation: https://doc.babylonjs.com/babylon101/lights",
    "family": "lights",
    "name": "DirectionalLight",
    "props": [
      {
        "comment": "Fix frustum size for the shadow generation. This is disabled if the value is 0.",
        "name": "shadowFrustumSize",
        "type": "Number"
      },
      {
        "comment": "Gets the shadow projection scale against the optimal computed one.\n0.1 by default which means that the projection window is increase by 10% from the optimal size.\nThis does not impact in fixed frustum size (shadowFrustumSize being set)",
        "name": "shadowOrthoScale",
        "type": "Number"
      },
      {
        "comment": "Automatically compute the projection matrix to best fit (including all the casters)\non each frame.",
        "name": "autoUpdateExtends",
        "type": "Boolean"
      }
    ]
  },
  "Disc": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a plane polygonal mesh.  By default, this is a disc\n* The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\n* The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\n* You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateDisc",
    "options": [
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "tessellation",
        "type": "Number"
      },
      {
        "name": "arc",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "DummyInternalTextureTracker": {
    "args": [],
    "comment": "Internal class used by the engine to get list of InternalTexture already bound to the GL context",
    "family": "materials",
    "name": "DummyInternalTextureTracker",
    "props": [
      {
        "comment": "Gets or set the previous tracker in the list",
        "name": "previous",
        "type": "Nullable"
      },
      {
        "comment": "Gets or set the next tracker in the list",
        "name": "next",
        "type": "Nullable"
      }
    ]
  },
  "DynamicTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "options",
        "type": "Any"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "format",
        "type": "Number"
      }
    ],
    "comment": "A class extending Texture allowing drawing on a texture",
    "family": "materials",
    "name": "DynamicTexture",
    "props": [
      {
        "comment": "Gets the current state of canRescale",
        "name": "canRescale",
        "type": "Boolean"
      }
    ]
  },
  "Engine": {
    "args": [
      {
        "name": "canvasOrContext",
        "type": "Nullable"
      },
      {
        "name": "antialias",
        "type": "Boolean"
      },
      {
        "name": "options",
        "type": "EngineOptions"
      },
      {
        "name": "adaptToDeviceRatio",
        "type": "Boolean"
      }
    ],
    "comment": "The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio",
    "family": "system",
    "name": "Engine",
    "props": [
      {
        "comment": "Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required",
        "name": "forcePOTTextures",
        "type": "Boolean"
      },
      {
        "comment": "Gets a boolean indicating if the engine is currently rendering in fullscreen mode",
        "name": "isFullscreen",
        "type": "Boolean"
      },
      {
        "comment": "Gets a boolean indicating if the pointer is currently locked",
        "name": "isPointerLock",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if back faces must be culled (true by default)",
        "name": "cullBackFaces",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun",
        "name": "renderEvenInBackground",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating that cache can be kept between frames",
        "name": "preventCacheWipeBetweenFrames",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest",
        "name": "enableOfflineSupport",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (Babylon.js will always consider the database is up to date)",
        "name": "disableManifestCheck",
        "type": "Boolean"
      },
      {
        "comment": "Gets the list of created scenes",
        "name": "scenes",
        "type": [
          "Scene"
        ]
      },
      {
        "comment": "Gets the list of created postprocesses",
        "name": "postProcesses",
        "type": [
          "PostProcess"
        ]
      },
      {
        "comment": "Gets or sets a boolean indicating if the engine should validate programs after compilation",
        "name": "validateShaderPrograms",
        "type": "Boolean"
      },
      {
        "comment": "Observable event triggered each time the rendering canvas is resized",
        "name": "onResizeObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable event triggered each time the canvas loses focus",
        "name": "onCanvasBlurObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable event triggered each time the canvas gains focus",
        "name": "onCanvasFocusObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable event triggered each time the canvas receives pointerout event",
        "name": "onCanvasPointerOutObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable event triggered before each texture is initialized",
        "name": "onBeforeTextureInitObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers",
        "name": "isInVRExclusivePointerMode",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported",
        "name": "disableUniformBuffers",
        "type": "Boolean"
      },
      {
        "comment": "Gets a boolean indicating that the engine supports uniform buffers",
        "name": "supportsUniformBuffers",
        "type": "Boolean"
      },
      {
        "comment": "Observable raised when the engine begins a new frame",
        "name": "onBeginFrameObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable raised when the engine ends the current frame",
        "name": "onEndFrameObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable raised when the engine is about to compile a shader",
        "name": "onBeforeShaderCompilationObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable raised when the engine has jsut compiled a shader",
        "name": "onAfterShaderCompilationObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets a boolean indicating that only power of 2 textures are supported\nPlease note that you can still use non power of 2 textures but in this case the engine will forcefully convert them",
        "name": "needPOTTextures",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a value indicating if we want to disable texture binding optmization.\nThis could be required on some buggy drivers which wants to have textures bound in a progressive order.\nBy default Babylon.js will try to let textures bound where they are and only update the samplers to point where the texture is",
        "name": "disableTextureBindingOptimization",
        "type": "Boolean"
      },
      {
        "comment": "Gets the audio engine",
        "name": "audioEngine",
        "type": "IAudioEngine"
      },
      {
        "comment": "Observable signaled when VR display mode changes",
        "name": "onVRDisplayChangedObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable signaled when VR request present is complete",
        "name": "onVRRequestPresentComplete",
        "type": "Observable"
      },
      {
        "comment": "Observable signaled when VR request present starts",
        "name": "onVRRequestPresentStart",
        "type": "Observable"
      },
      {
        "comment": "Observable signaled when a context lost event is raised",
        "name": "onContextLostObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable signaled when a context restored event is raised",
        "name": "onContextRestoredObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events",
        "name": "doNotHandleContextLost",
        "type": "Boolean"
      },
      {
        "comment": "Turn this value on if you want to pause FPS computation when in background",
        "name": "disablePerformanceMonitorInBackground",
        "type": "Boolean"
      },
      {
        "comment": "Gets the performance monitor attached to this engine",
        "name": "performanceMonitor",
        "type": "PerformanceMonitor"
      },
      {
        "comment": "Gets the list of texture formats supported",
        "name": "texturesSupported",
        "type": [
          null
        ]
      },
      {
        "comment": "Gets the list of texture formats in use",
        "name": "textureFormatInUse",
        "type": "Nullable"
      },
      {
        "comment": "Gets the current viewport",
        "name": "currentViewport",
        "type": "Nullable"
      },
      {
        "comment": "Gets the default empty texture",
        "name": "emptyTexture",
        "type": "InternalTexture"
      },
      {
        "comment": "Gets the default empty 3D texture",
        "name": "emptyTexture3D",
        "type": "InternalTexture"
      },
      {
        "comment": "Gets the default empty cube texture",
        "name": "emptyCubeTexture",
        "type": "InternalTexture"
      },
      {
        "comment": "Defines whether the engine has been created with the premultipliedAlpha option on or not.",
        "name": "premultipliedAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Gets version of the current webGL context",
        "name": "webGLVersion",
        "type": "Number"
      },
      {
        "comment": "Returns true if the stencil buffer has been enabled through the creation option of the context.",
        "name": "isStencilEnable",
        "type": "Boolean"
      },
      {
        "name": "drawCalls",
        "type": "Number"
      },
      {
        "name": "drawCallsPerfCounter",
        "type": "Nullable"
      },
      {
        "name": "bindUnboundFramebuffer"
      },
      {
        "name": "bindIndexBuffer"
      },
      {
        "name": "bindBuffer"
      },
      {
        "comment": "In case you are sharing the context with other applications, it might\nbe interested to not cache the unpack flip y state to ensure a consistent\nvalue would be set.",
        "name": "enableUnpackFlipYCached",
        "type": "Boolean"
      },
      {
        "name": "setProgram"
      },
      {
        "comment": "Gets the current loading screen object",
        "name": "loadingScreen",
        "type": "ILoadingScreen"
      },
      {
        "comment": "Sets the current loading screen text",
        "name": "loadingUIText",
        "type": "String"
      },
      {
        "comment": "Sets the current loading screen background color",
        "name": "loadingUIBackgroundColor",
        "type": "String"
      }
    ]
  },
  "FollowCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "lockedTarget",
        "type": "Nullable"
      }
    ],
    "comment": "A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\nan arc rotate version arcFollowCamera are available.",
    "family": "cameras",
    "name": "FollowCamera",
    "props": [
      {
        "comment": "Distance the follow camera should follow an object at",
        "name": "radius",
        "type": "Number"
      },
      {
        "comment": "Define a rotation offset between the camera and the object it follows",
        "name": "rotationOffset",
        "type": "Number"
      },
      {
        "comment": "Define a height offset between the camera and the object it follows.\nIt can help following an object from the top (like a car chaing a plane)",
        "name": "heightOffset",
        "type": "Number"
      },
      {
        "comment": "Define how fast the camera can accelerate to follow it s target.",
        "name": "cameraAcceleration",
        "type": "Number"
      },
      {
        "comment": "Define the speed limit of the camera following an object.",
        "name": "maxCameraSpeed",
        "type": "Number"
      },
      {
        "comment": "Define the target of the camera.",
        "name": "lockedTarget",
        "type": "Nullable"
      }
    ]
  },
  "FreeCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "setActiveOnSceneIfNoneActive",
        "type": "Boolean"
      }
    ],
    "comment": "This represents a free type of camera. It can be usefull in First Person Shooter game for instance.\nPlease consider using the new UniversalCamera instead as it adds more functionality like the gamepad.",
    "family": "cameras",
    "name": "FreeCamera",
    "props": [
      {
        "comment": "Define the collision ellipsoid of the camera.\nThis is helpful to simulate a camera body like the player body around the camera",
        "name": "ellipsoid",
        "type": "Vector3"
      },
      {
        "comment": "Define an offset for the position of the ellipsoid around the camera.\nThis can be helpful to determine the center of the body near the gravity center of the body\ninstead of its head.",
        "name": "ellipsoidOffset",
        "type": "Vector3"
      },
      {
        "comment": "Enable or disable collisions of the camera with the rest of the scene objects.",
        "name": "checkCollisions",
        "type": "Boolean"
      },
      {
        "comment": "Enable or disable gravity on the camera.",
        "name": "applyGravity",
        "type": "Boolean"
      },
      {
        "comment": "Define the input manager associated to the camera.",
        "name": "inputs",
        "type": "FreeCameraInputsManager"
      },
      {
        "comment": "Gets the input sensibility for a mouse input. (default is 2000.0)\nHigher values reduce sensitivity.",
        "name": "angularSensibility",
        "type": "Number"
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control the forward move of the camera.",
        "name": "keysUp",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control the backward move of the camera.",
        "name": "keysDown",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control the left strafe move of the camera.",
        "name": "keysLeft",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Gets or Set the list of keyboard keys used to control the right strafe move of the camera.",
        "name": "keysRight",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Event raised when the camera collide with a mesh in the scene.",
        "name": "onCollide",
        "type": "Function"
      },
      {
        "comment": "Define a collision mask to limit the list of object the camera can collide with",
        "name": "collisionMask",
        "type": "Number"
      }
    ]
  },
  "GamepadCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "This represents a FPS type of camera. This is only here for back compat purpose.\nPlease use the UniversalCamera instead as both are identical.",
    "family": "cameras",
    "name": "GamepadCamera",
    "props": []
  },
  "Ground": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a ground mesh\n* The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\n* The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateGround",
    "options": [
      {
        "name": "width",
        "type": "Number"
      },
      {
        "name": "height",
        "type": "Number"
      },
      {
        "name": "subdivisions",
        "type": "Number"
      },
      {
        "name": "subdivisionsX",
        "type": "Number"
      },
      {
        "name": "subdivisionsY",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "GroundFromHeightMap": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "url",
        "type": "String"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a ground mesh from a height map\n* The parameter `url` sets the URL of the height map image resource.\n* The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\n* The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\n* The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\n* The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\n* The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\n* The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\n* The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.",
    "family": "meshes",
    "name": "CreateGroundFromHeightMap",
    "options": [
      {
        "name": "width",
        "type": "Number"
      },
      {
        "name": "height",
        "type": "Number"
      },
      {
        "name": "subdivisions",
        "type": "Number"
      },
      {
        "name": "minHeight",
        "type": "Number"
      },
      {
        "name": "maxHeight",
        "type": "Number"
      },
      {
        "name": "colorFilter",
        "type": "Color3"
      },
      {
        "name": "alphaFilter",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "onReady",
        "type": "Function"
      }
    ],
    "props": [],
    "return": "GroundMesh"
  },
  "HDRCubeTexture": {
    "args": [
      {
        "name": "url",
        "type": "String"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "noMipmap",
        "type": "Boolean"
      },
      {
        "name": "generateHarmonics",
        "type": "Boolean"
      },
      {
        "name": "gammaSpace",
        "type": "Boolean"
      },
      {
        "name": "reserved",
        "type": "Boolean"
      },
      {
        "name": "onLoad",
        "type": "Nullable"
      },
      {
        "name": "onError",
        "type": "Nullable"
      }
    ],
    "comment": "This represents a texture coming from an HDR input.\n\nThe only supported format is currently panorama picture stored in RGBE format.\nExample of such files can be found on HDRLib: http://hdrlib.com/",
    "family": "materials",
    "name": "HDRCubeTexture",
    "props": [
      {
        "comment": "The texture URL.",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "The texture coordinates mode. As this texture is stored in a cube format, please modify carefully.",
        "name": "coordinatesMode",
        "type": "Number"
      },
      {
        "comment": "Sets wether or not the texture is blocking during loading.",
        "name": "isBlocking",
        "type": "Boolean"
      },
      {
        "comment": "Sets texture matrix rotation angle around Y axis in radians.",
        "name": "rotationY",
        "type": "Number"
      },
      {
        "comment": "Gets or sets the center of the bounding box associated with the cube texture\nIt must define where the camera used to render the texture was set",
        "name": "boundingBoxPosition",
        "type": "Vector3"
      },
      {
        "comment": "Gets or sets the size of the bounding box associated with the cube texture\nWhen defined, the cubemap will switch to local mode",
        "name": "boundingBoxSize",
        "type": "Vector3"
      },
      {
        "comment": "Occurs when the file is raw .hdr file.",
        "name": "loadTexture"
      }
    ]
  },
  "HDRCubeTextureAssetTask": {
    "args": [
      {
        "comment": "Defines the name of the task",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Defines the location of the file to load",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Defines the desired size (the more it increases the longer the generation will be)",
        "name": "size",
        "type": "Number"
      },
      {
        "comment": "Defines if mipmaps should not be generated (default is false)",
        "name": "noMipmap",
        "type": "Boolean"
      },
      {
        "comment": "Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)",
        "name": "generateHarmonics",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)",
        "name": "gammaSpace",
        "type": "Boolean"
      },
      {
        "comment": "Internal Use Only",
        "name": "reserved",
        "type": "Boolean"
      }
    ],
    "comment": "Define a task used by AssetsManager to load HDR cube textures",
    "family": "materials",
    "name": "HDRCubeTextureAssetTask",
    "props": [
      {
        "comment": "Defines the name of the task",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Defines the location of the file to load",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Defines the desired size (the more it increases the longer the generation will be)",
        "name": "size",
        "type": "Number"
      },
      {
        "comment": "Defines if mipmaps should not be generated (default is false)",
        "name": "noMipmap",
        "type": "Boolean"
      },
      {
        "comment": "Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)",
        "name": "generateHarmonics",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)",
        "name": "gammaSpace",
        "type": "Boolean"
      },
      {
        "comment": "Internal Use Only",
        "name": "reserved",
        "type": "Boolean"
      },
      {
        "comment": "Gets the loaded texture",
        "name": "texture",
        "type": "HDRCubeTexture"
      },
      {
        "comment": "Callback called when the task is successful",
        "name": "onSuccess",
        "type": "Function"
      },
      {
        "comment": "Callback called when the task is successful",
        "name": "onError",
        "type": "Function"
      }
    ]
  },
  "HemisphericLight": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "direction",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "The HemisphericLight simulates the ambient environment light,\nso the passed direction is the light reflection direction, not the incoming direction.",
    "family": "lights",
    "name": "HemisphericLight",
    "props": [
      {
        "comment": "The groundColor is the light in the opposite direction to the one specified during creation.\nYou can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.",
        "name": "groundColor",
        "type": "Color3"
      },
      {
        "comment": "The light reflection direction, not the incoming direction.",
        "name": "direction",
        "type": "Vector3"
      }
    ]
  },
  "IcoSphere": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\n* The parameter `radius` sets the radius size (float) of the icosphere (default 1)\n* You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\n* The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\n* The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateIcoSphere",
    "options": [
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "radiusX",
        "type": "Number"
      },
      {
        "name": "radiusY",
        "type": "Number"
      },
      {
        "name": "radiusZ",
        "type": "Number"
      },
      {
        "name": "flat",
        "type": "Boolean"
      },
      {
        "name": "subdivisions",
        "type": "Number"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "InternalTexture": {
    "args": [
      {
        "name": "engine",
        "type": "Engine"
      },
      {
        "name": "dataSource",
        "type": "Number"
      }
    ],
    "comment": "Class used to store data associated with WebGL texture data for the engine\nThis class should not be used directly",
    "family": "materials",
    "name": "InternalTexture",
    "props": [
      {
        "comment": "Defines if the texture is ready",
        "name": "isReady",
        "type": "Boolean"
      },
      {
        "comment": "Defines if the texture is a cube texture",
        "name": "isCube",
        "type": "Boolean"
      },
      {
        "comment": "Defines if the texture contains 3D data",
        "name": "is3D",
        "type": "Boolean"
      },
      {
        "comment": "Gets the URL used to load this texture",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Gets the sampling mode of the texture",
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "comment": "Gets a boolean indicating if the texture needs mipmaps generation",
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "comment": "Gets the number of samples used by the texture (WebGL2+ only)",
        "name": "samples",
        "type": "Number"
      },
      {
        "comment": "Gets the type of the texture (int, float...)",
        "name": "type",
        "type": "Number"
      },
      {
        "comment": "Gets the format of the texture (RGB, RGBA...)",
        "name": "format",
        "type": "Number"
      },
      {
        "comment": "Observable called when the texture is loaded",
        "name": "onLoadedObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets the width of the texture",
        "name": "width",
        "type": "Number"
      },
      {
        "comment": "Gets the height of the texture",
        "name": "height",
        "type": "Number"
      },
      {
        "comment": "Gets the depth of the texture",
        "name": "depth",
        "type": "Number"
      },
      {
        "comment": "Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)",
        "name": "baseWidth",
        "type": "Number"
      },
      {
        "comment": "Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)",
        "name": "baseHeight",
        "type": "Number"
      },
      {
        "comment": "Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)",
        "name": "baseDepth",
        "type": "Number"
      },
      {
        "comment": "Gets a boolean indicating if the texture is inverted on Y axis",
        "name": "invertY",
        "type": "Boolean"
      },
      {
        "comment": "Gets or set the previous tracker in the list",
        "name": "previous",
        "type": "Nullable"
      },
      {
        "comment": "Gets or set the next tracker in the list",
        "name": "next",
        "type": "Nullable"
      },
      {
        "comment": "Gets the data source type of the texture (can be one of the BABYLON.InternalTexture.DATASOURCE_XXXX)",
        "name": "dataSource",
        "type": "Number"
      }
    ]
  },
  "KhronosTextureContainer": {
    "args": [
      {
        "comment": "contents of the KTX container file",
        "name": "arrayBuffer",
        "type": "Any"
      },
      {
        "name": "facesExpected",
        "type": "Number"
      },
      {
        "name": "threeDExpected",
        "type": "Boolean"
      },
      {
        "name": "textureArrayExpected",
        "type": "Boolean"
      }
    ],
    "comment": "for description see https://www.khronos.org/opengles/sdk/tools/KTX/\nfor file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/",
    "family": "materials",
    "name": "KhronosTextureContainer",
    "props": [
      {
        "comment": "contents of the KTX container file",
        "name": "arrayBuffer",
        "type": "Any"
      },
      {
        "comment": "Gets the openGL type",
        "name": "glType",
        "type": "Number"
      },
      {
        "comment": "Gets the openGL type size",
        "name": "glTypeSize",
        "type": "Number"
      },
      {
        "comment": "Gets the openGL format",
        "name": "glFormat",
        "type": "Number"
      },
      {
        "comment": "Gets the openGL internal format",
        "name": "glInternalFormat",
        "type": "Number"
      },
      {
        "comment": "Gets the base internal format",
        "name": "glBaseInternalFormat",
        "type": "Number"
      },
      {
        "comment": "Gets image width in pixel",
        "name": "pixelWidth",
        "type": "Number"
      },
      {
        "comment": "Gets image height in pixel",
        "name": "pixelHeight",
        "type": "Number"
      },
      {
        "comment": "Gets image depth in pixels",
        "name": "pixelDepth",
        "type": "Number"
      },
      {
        "comment": "Gets the number of array elements",
        "name": "numberOfArrayElements",
        "type": "Number"
      },
      {
        "comment": "Gets the number of faces",
        "name": "numberOfFaces",
        "type": "Number"
      },
      {
        "comment": "Gets the number of mipmap levels",
        "name": "numberOfMipmapLevels",
        "type": "Number"
      },
      {
        "comment": "Gets the bytes of key value data",
        "name": "bytesOfKeyValueData",
        "type": "Number"
      },
      {
        "comment": "Gets the load type",
        "name": "loadType",
        "type": "Number"
      }
    ]
  },
  "Lathe": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates lathe mesh.\nThe lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe\n* The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\n* The parameter `radius` (positive float, default 1) is the radius value of the lathe\n* The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\n* The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\n* The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\n* The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\n* The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateLathe",
    "options": [
      {
        "name": "shape",
        "type": [
          "Vector3"
        ]
      },
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "tessellation",
        "type": "Number"
      },
      {
        "name": "clip",
        "type": "Number"
      },
      {
        "name": "arc",
        "type": "Number"
      },
      {
        "name": "closed",
        "type": "Boolean"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      },
      {
        "name": "cap",
        "type": "Number"
      },
      {
        "name": "invertUV",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "Light": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Base class of all the lights in Babylon. It groups all the generic information about lights.\nLights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\nAll meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.",
    "family": "lights",
    "name": "Light",
    "props": [
      {
        "comment": "Diffuse gives the basic color to an object.",
        "name": "diffuse",
        "type": "Color3"
      },
      {
        "comment": "Specular produces a highlight color on an object.\nNote: This is note affecting PBR materials.",
        "name": "specular",
        "type": "Color3"
      },
      {
        "comment": "Defines the falloff type for this light. This lets overrriding how punctual light are\nfalling off base on range or angle.\nThis can be set to any values in Light.FALLOFF_x.\n\nNote: This is only usefull for PBR Materials at the moment. This could be extended if required to\nother types of materials.",
        "name": "falloffType",
        "type": "Number"
      },
      {
        "comment": "Strength of the light.\nNote: By default it is define in the framework own unit.\nNote: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.",
        "name": "intensity",
        "type": "Number"
      },
      {
        "comment": "Defines how far from the source the light is impacting in scene units.\nNote: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.",
        "name": "range",
        "type": "Number"
      },
      {
        "comment": "Gets the photometric scale used to interpret the intensity.\nThis is only relevant with PBR Materials where the light intensity can be defined in a physical way.",
        "name": "intensityMode",
        "type": "Number"
      },
      {
        "comment": "Gets the light radius used by PBR Materials to simulate soft area lights.",
        "name": "radius",
        "type": "Number"
      },
      {
        "comment": "Defines the rendering priority of the lights. It can help in case of fallback or number of lights\nexceeding the number allowed of the materials.",
        "name": "renderPriority",
        "type": "Number"
      },
      {
        "comment": "Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\nthe current shadow generator.",
        "name": "shadowEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets the only meshes impacted by this light.",
        "name": "includedOnlyMeshes",
        "type": [
          "AbstractMesh"
        ]
      },
      {
        "comment": "Gets the meshes not impacted by this light.",
        "name": "excludedMeshes",
        "type": [
          "AbstractMesh"
        ]
      },
      {
        "comment": "Gets the layer id use to find what meshes are not impacted by the light.\nInactive if 0",
        "name": "excludeWithLayerMask",
        "type": "Number"
      },
      {
        "comment": "Gets the layer id use to find what meshes are impacted by the light.\nInactive if 0",
        "name": "includeOnlyWithLayerMask",
        "type": "Number"
      },
      {
        "comment": "Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)",
        "name": "lightmapMode",
        "type": "Number"
      }
    ]
  },
  "LineSystem": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\n* A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\n* Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\n* The parameter `lines` is an array of lines, each line being an array of successive Vector3\n* The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\n* The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\n* The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n* Updating a simple Line mesh, you just need to update every line in the `lines` array : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n* When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateLineSystem",
    "options": [
      {
        "name": "lines",
        "type": [
          [
            "Vector3"
          ]
        ]
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "instance",
        "type": "Nullable"
      },
      {
        "name": "colors",
        "type": "Nullable"
      },
      {
        "name": "useVertexAlpha",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "LinesMesh"
  },
  "Lines": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a line mesh\nA line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n* Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n* The parameter `points` is an array successive Vector3\n* The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n* The optional parameter `colors` is an array of successive Color4, one per line point\n* The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\n* When updating an instance, remember that only point positions can change, not the number of points\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateLines",
    "options": [
      {
        "name": "points",
        "type": [
          "Vector3"
        ]
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "instance",
        "type": "Nullable"
      },
      {
        "name": "colors",
        "type": [
          "Color4"
        ]
      },
      {
        "name": "useVertexAlpha",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "LinesMesh"
  },
  "Material": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "doNotAdd",
        "type": "Boolean"
      }
    ],
    "comment": "Base class for the main features of a material in Babylon.js",
    "family": "materials",
    "name": "Material",
    "props": [
      {
        "comment": "The ID of the material",
        "name": "id",
        "type": "String"
      },
      {
        "comment": "Gets or sets the unique id of the material",
        "name": "uniqueId",
        "type": "Number"
      },
      {
        "comment": "The name of the material",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Specifies if the ready state should be checked on each call",
        "name": "checkReadyOnEveryCall",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the ready state should be checked once",
        "name": "checkReadyOnlyOnce",
        "type": "Boolean"
      },
      {
        "comment": "The state of the material",
        "name": "state",
        "type": "String"
      },
      {
        "comment": "Sets the alpha value of the material",
        "name": "alpha",
        "type": "Number"
      },
      {
        "comment": "Sets the back-face culling state",
        "name": "backFaceCulling",
        "type": "Boolean"
      },
      {
        "comment": "Stores the value for side orientation",
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "comment": "Callback triggered when the material is compiled",
        "name": "onCompiled",
        "type": "Function"
      },
      {
        "comment": "Callback triggered when an error occurs",
        "name": "onError",
        "type": "Function"
      },
      {
        "comment": "Callback triggered to get the render target textures",
        "name": "getRenderTargetTextures",
        "type": "Function"
      },
      {
        "comment": "Gets a boolean indicating that current material needs to register RTT",
        "name": "hasRenderTargetTextures",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the material should be serialized",
        "name": "doNotSerialize",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the effect should be stored on sub meshes",
        "name": "storeEffectOnSubMeshes",
        "type": "Boolean"
      },
      {
        "comment": "Stores the animations for the material",
        "name": "animations",
        "type": [
          null
        ]
      },
      {
        "comment": "An event triggered when the material is disposed",
        "name": "onDisposeObservable",
        "type": "Observable"
      },
      {
        "comment": "Called during a dispose event",
        "name": "onDispose",
        "type": "Function"
      },
      {
        "comment": "An event triggered when the material is bound",
        "name": "onBindObservable",
        "type": "Observable"
      },
      {
        "comment": "Called during a bind event",
        "name": "onBind",
        "type": "Function"
      },
      {
        "comment": "An event triggered when the material is unbound",
        "name": "onUnBindObservable",
        "type": "Observable"
      },
      {
        "comment": "Sets the value of the alpha mode.\n\n| Value | Type | Description |\n| --- | --- | --- |\n| 0 | ALPHA_DISABLE |   |\n| 1 | ALPHA_ADD |   |\n| 2 | ALPHA_COMBINE |   |\n| 3 | ALPHA_SUBTRACT |   |\n| 4 | ALPHA_MULTIPLY |   |\n| 5 | ALPHA_MAXIMIZED |   |\n| 6 | ALPHA_ONEONE |   |\n| 7 | ALPHA_PREMULTIPLIED |   |\n| 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\n| 9 | ALPHA_INTERPOLATE |   |\n| 10 | ALPHA_SCREENMODE |   |",
        "name": "alphaMode",
        "type": "Number"
      },
      {
        "comment": "Sets the need depth pre-pass value",
        "name": "needDepthPrePass",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if depth writing should be disabled",
        "name": "disableDepthWrite",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if depth writing should be forced",
        "name": "forceDepthWrite",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if there should be a separate pass for culling",
        "name": "separateCullingPass",
        "type": "Boolean"
      },
      {
        "comment": "Sets the state for enabling fog",
        "name": "fogEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Stores the size of points",
        "name": "pointSize",
        "type": "Number"
      },
      {
        "comment": "Stores the z offset value",
        "name": "zOffset",
        "type": "Number"
      },
      {
        "comment": "Gets a value specifying if wireframe mode is enabled",
        "name": "wireframe",
        "type": "Boolean"
      },
      {
        "comment": "Gets the value specifying if point clouds are enabled",
        "name": "pointsCloud",
        "type": "Boolean"
      },
      {
        "comment": "Gets the material fill mode",
        "name": "fillMode",
        "type": "Number"
      },
      {
        "comment": "Specifies if updates for the material been locked",
        "name": "isFrozen",
        "type": "Boolean"
      }
    ]
  },
  "MaterialHelper": {
    "args": [],
    "comment": "\"Static Class\" containing the most commonly used helper while dealing with material for\nrendering purpose.\n\nIt contains the basic tools to help defining defines, binding uniform for the common part of the materials.\n\nThis works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.",
    "family": "materials",
    "name": "MaterialHelper",
    "props": []
  },
  "MirrorTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "size",
        "type": "Union"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "type",
        "type": "Number"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "generateDepthBuffer",
        "type": "Boolean"
      }
    ],
    "comment": "Mirror texture can be used to simulate the view from a mirror in a scene.\nIt will dynamically be rendered every frame to adapt to the camera point of view.\nYou can then easily use it as a reflectionTexture on a flat surface.\nIn case the surface is not a plane, please consider relying on reflection probes.",
    "family": "materials",
    "name": "MirrorTexture",
    "props": [
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "comment": "Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.\nIt is possible to directly set the mirrorPlane by directly using a BABYLON.Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.",
        "name": "mirrorPlane",
        "type": "Plane"
      },
      {
        "comment": "Define the blur ratio used to blur the reflection if needed.",
        "name": "blurRatio",
        "type": "Number"
      },
      {
        "comment": "Define the adaptive blur kernel used to blur the reflection if needed.\nThis will autocompute the closest best match for the `blurKernel`",
        "name": "adaptiveBlurKernel",
        "type": "Number"
      },
      {
        "comment": "Define the blur kernel used to blur the reflection if needed.\nPlease consider using `adaptiveBlurKernel` as it could find the closest best value for you.",
        "name": "blurKernel",
        "type": "Number"
      },
      {
        "comment": "Define the blur kernel on the X Axis used to blur the reflection if needed.\nPlease consider using `adaptiveBlurKernel` as it could find the closest best value for you.",
        "name": "blurKernelX",
        "type": "Number"
      },
      {
        "comment": "Define the blur kernel on the Y Axis used to blur the reflection if needed.\nPlease consider using `adaptiveBlurKernel` as it could find the closest best value for you.",
        "name": "blurKernelY",
        "type": "Number"
      }
    ]
  },
  "MultiMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "A multi-material is used to apply different materials to different parts of the same object without the need of\nseparate meshes. This can be use to improve performances.",
    "family": "materials",
    "name": "MultiMaterial",
    "props": [
      {
        "comment": "Gets or Sets the list of Materials used within the multi material.\nThey need to be ordered according to the submeshes order in the associated mesh",
        "name": "subMaterials",
        "type": [
          "Nullable"
        ]
      }
    ]
  },
  "NoiseProceduralTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "fallbackTexture",
        "type": "Texture"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      }
    ],
    "comment": "Class used to generate noise procedural textures",
    "family": "materials",
    "name": "NoiseProceduralTexture",
    "props": [
      {
        "comment": "Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2)",
        "name": "brightness",
        "type": "Number"
      },
      {
        "comment": "Defines the number of octaves to process",
        "name": "octaves",
        "type": "Number"
      },
      {
        "comment": "Defines the level of persistence (0.8 by default)",
        "name": "persistence",
        "type": "Number"
      },
      {
        "comment": "Gets or sets animation speed factor (default is 1)",
        "name": "animationSpeedFactor",
        "type": "Number"
      }
    ]
  },
  "PBRBaseMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "The Physically based material base class of BJS.\n\nThis offers the main features of a standard PBR material.\nFor more information, please refer to the documentation :\nhttp://doc.babylonjs.com/extensions/Physically_Based_Rendering",
    "family": "materials",
    "name": "PBRBaseMaterial",
    "props": [
      {
        "comment": "Gets a boolean indicating that current material needs to register RTT",
        "name": "hasRenderTargetTextures",
        "type": "Boolean"
      },
      {
        "comment": "Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.",
        "name": "useLogarithmicDepth",
        "type": "Boolean"
      },
      {
        "comment": "Gets the current transparency mode.",
        "name": "transparencyMode",
        "type": "Nullable"
      }
    ]
  },
  "PBRBaseSimpleMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "The Physically based simple base material of BJS.\n\nThis enables better naming and convention enforcements on top of the pbrMaterial.\nIt is used as the base class for both the specGloss and metalRough conventions.",
    "family": "materials",
    "name": "PBRBaseSimpleMaterial",
    "props": [
      {
        "comment": "Number of Simultaneous lights allowed on the material.",
        "name": "maxSimultaneousLights",
        "type": "Number"
      },
      {
        "comment": "If sets to true, disables all the lights affecting the material.",
        "name": "disableLighting",
        "type": "Boolean"
      },
      {
        "comment": "Environment Texture used in the material (this is use for both reflection and environment lighting).",
        "name": "environmentTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "If sets to true, x component of normal map value will invert (x = 1.0 - x).",
        "name": "invertNormalMapX",
        "type": "Boolean"
      },
      {
        "comment": "If sets to true, y component of normal map value will invert (y = 1.0 - y).",
        "name": "invertNormalMapY",
        "type": "Boolean"
      },
      {
        "comment": "Normal map used in the model.",
        "name": "normalTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Emissivie color used to self-illuminate the model.",
        "name": "emissiveColor",
        "type": "Color3"
      },
      {
        "comment": "Emissivie texture used to self-illuminate the model.",
        "name": "emissiveTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Occlusion Channel Strenght.",
        "name": "occlusionStrength",
        "type": "Number"
      },
      {
        "comment": "Occlusion Texture of the material (adding extra occlusion effects).",
        "name": "occlusionTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Defines the alpha limits in alpha test mode.",
        "name": "alphaCutOff",
        "type": "Number"
      },
      {
        "comment": "Gets the current double sided mode.",
        "name": "doubleSided",
        "type": "Boolean"
      },
      {
        "comment": "Stores the pre-calculated light information of a mesh in a texture.",
        "name": "lightmapTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "If true, the light map contains occlusion information instead of lighting info.",
        "name": "useLightmapAsShadowmap",
        "type": "Boolean"
      }
    ]
  },
  "PBRMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "The Physically based material of BJS.\n\nThis offers the main features of a standard PBR material.\nFor more information, please refer to the documentation :\nhttp://doc.babylonjs.com/extensions/Physically_Based_Rendering",
    "family": "materials",
    "name": "PBRMaterial",
    "props": [
      {
        "comment": "Intensity of the direct lights e.g. the four lights available in your scene.\nThis impacts both the direct diffuse and specular highlights.",
        "name": "directIntensity",
        "type": "Number"
      },
      {
        "comment": "Intensity of the emissive part of the material.\nThis helps controlling the emissive effect without modifying the emissive color.",
        "name": "emissiveIntensity",
        "type": "Number"
      },
      {
        "comment": "Intensity of the environment e.g. how much the environment will light the object\neither through harmonics for rough material or through the refelction for shiny ones.",
        "name": "environmentIntensity",
        "type": "Number"
      },
      {
        "comment": "This is a special control allowing the reduction of the specular highlights coming from the\nfour lights of the scene. Those highlights may not be needed in full environment lighting.",
        "name": "specularIntensity",
        "type": "Number"
      },
      {
        "comment": "Debug Control allowing disabling the bump map on this material.",
        "name": "disableBumpMap",
        "type": "Boolean"
      },
      {
        "comment": "AKA Diffuse Texture in standard nomenclature.",
        "name": "albedoTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "AKA Occlusion Texture in other nomenclature.",
        "name": "ambientTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "AKA Occlusion Texture Intensity in other nomenclature.",
        "name": "ambientTextureStrength",
        "type": "Number"
      },
      {
        "comment": "Defines how much the AO map is occluding the analytical lights (point spot...).\n1 means it completely occludes it\n0 mean it has no impact",
        "name": "ambientTextureImpactOnAnalyticalLights",
        "type": "Number"
      },
      {
        "comment": "Stores the alpha values in a texture.",
        "name": "opacityTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Stores the reflection values in a texture.",
        "name": "reflectionTexture",
        "type": "Nullable"
      },
      {
        "comment": "Stores the emissive values in a texture.",
        "name": "emissiveTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "AKA Specular texture in other nomenclature.",
        "name": "reflectivityTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Used to switch from specular/glossiness to metallic/roughness workflow.",
        "name": "metallicTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Specifies the metallic scalar of the metallic/roughness workflow.\nCan also be used to scale the metalness values of the metallic texture.",
        "name": "metallic",
        "type": "Nullable"
      },
      {
        "comment": "Specifies the roughness scalar of the metallic/roughness workflow.\nCan also be used to scale the roughness values of the metallic texture.",
        "name": "roughness",
        "type": "Nullable"
      },
      {
        "comment": "Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\nGray Scale represents roughness in metallic mode and glossiness in specular mode.",
        "name": "microSurfaceTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Stores surface normal data used to displace a mesh in a texture.",
        "name": "bumpTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Stores the pre-calculated light information of a mesh in a texture.",
        "name": "lightmapTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Stores the refracted light information in a texture.",
        "name": "refractionTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "The color of a material in ambient lighting.",
        "name": "ambientColor",
        "type": "Color3"
      },
      {
        "comment": "AKA Diffuse Color in other nomenclature.",
        "name": "albedoColor",
        "type": "Color3"
      },
      {
        "comment": "AKA Specular Color in other nomenclature.",
        "name": "reflectivityColor",
        "type": "Color3"
      },
      {
        "comment": "The color reflected from the material.",
        "name": "reflectionColor",
        "type": "Color3"
      },
      {
        "comment": "The color emitted from the material.",
        "name": "emissiveColor",
        "type": "Color3"
      },
      {
        "comment": "AKA Glossiness in other nomenclature.",
        "name": "microSurface",
        "type": "Number"
      },
      {
        "comment": "source material index of refraction (IOR)' / 'destination material IOR.",
        "name": "indexOfRefraction",
        "type": "Number"
      },
      {
        "comment": "Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.",
        "name": "invertRefractionY",
        "type": "Boolean"
      },
      {
        "comment": "This parameters will make the material used its opacity to control how much it is refracting aginst not.\nMaterials half opaque for instance using refraction could benefit from this control.",
        "name": "linkRefractionWithTransparency",
        "type": "Boolean"
      },
      {
        "comment": "If true, the light map contains occlusion information instead of lighting info.",
        "name": "useLightmapAsShadowmap",
        "type": "Boolean"
      },
      {
        "comment": "Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.",
        "name": "useAlphaFromAlbedoTexture",
        "type": "Boolean"
      },
      {
        "comment": "Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.",
        "name": "forceAlphaTest",
        "type": "Boolean"
      },
      {
        "comment": "Defines the alpha limits in alpha test mode.",
        "name": "alphaCutOff",
        "type": "Number"
      },
      {
        "comment": "Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).\nA car glass is a good exemple of that. When sun reflects on it you can not see what is behind.",
        "name": "useSpecularOverAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the reflectivity texture contains the glossiness information in its alpha channel.",
        "name": "useMicroSurfaceFromReflectivityMapAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the metallic texture contains the roughness information in its alpha channel.",
        "name": "useRoughnessFromMetallicTextureAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the metallic texture contains the roughness information in its green channel.",
        "name": "useRoughnessFromMetallicTextureGreen",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the metallic texture contains the metallness information in its blue channel.",
        "name": "useMetallnessFromMetallicTextureBlue",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the metallic texture contains the ambient occlusion information in its red channel.",
        "name": "useAmbientOcclusionFromMetallicTextureRed",
        "type": "Boolean"
      },
      {
        "comment": "Specifies if the ambient texture contains the ambient occlusion information in its red channel only.",
        "name": "useAmbientInGrayScale",
        "type": "Boolean"
      },
      {
        "comment": "In case the reflectivity map does not contain the microsurface information in its alpha channel,\nThe material will try to infer what glossiness each pixel should be.",
        "name": "useAutoMicroSurfaceFromReflectivityMap",
        "type": "Boolean"
      },
      {
        "comment": "BJS is using an harcoded light falloff based on a manually sets up range.\nIn PBR, one way to represents the fallof is to use the inverse squared root algorythm.\nThis parameter can help you switch back to the BJS mode in order to create scenes using both materials.",
        "name": "usePhysicalLightFalloff",
        "type": "Boolean"
      },
      {
        "comment": "In order to support the falloff compatibility with gltf, a special mode has been added\nto reproduce the gltf light falloff.",
        "name": "useGLTFLightFalloff",
        "type": "Boolean"
      },
      {
        "comment": "Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).\nA car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.",
        "name": "useRadianceOverAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Allows using an object space normal map (instead of tangent space).",
        "name": "useObjectSpaceNormalMap",
        "type": "Boolean"
      },
      {
        "comment": "Allows using the bump map in parallax mode.",
        "name": "useParallax",
        "type": "Boolean"
      },
      {
        "comment": "Allows using the bump map in parallax occlusion mode.",
        "name": "useParallaxOcclusion",
        "type": "Boolean"
      },
      {
        "comment": "Controls the scale bias of the parallax mode.",
        "name": "parallaxScaleBias",
        "type": "Number"
      },
      {
        "comment": "If sets to true, disables all the lights affecting the material.",
        "name": "disableLighting",
        "type": "Boolean"
      },
      {
        "comment": "Force the shader to compute irradiance in the fragment shader in order to take bump in account.",
        "name": "forceIrradianceInFragment",
        "type": "Boolean"
      },
      {
        "comment": "Number of Simultaneous lights allowed on the material.",
        "name": "maxSimultaneousLights",
        "type": "Number"
      },
      {
        "comment": "If sets to true, x component of normal map value will invert (x = 1.0 - x).",
        "name": "invertNormalMapX",
        "type": "Boolean"
      },
      {
        "comment": "If sets to true, y component of normal map value will invert (y = 1.0 - y).",
        "name": "invertNormalMapY",
        "type": "Boolean"
      },
      {
        "comment": "If sets to true and backfaceCulling is false, normals will be flipped on the backside.",
        "name": "twoSidedLighting",
        "type": "Boolean"
      },
      {
        "comment": "A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\nAnd/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)",
        "name": "useAlphaFresnel",
        "type": "Boolean"
      },
      {
        "comment": "A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\nAnd/Or occlude the blended part. (alpha stays linear to compute the fresnel)",
        "name": "useLinearAlphaFresnel",
        "type": "Boolean"
      },
      {
        "comment": "A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\nAnd/Or occlude the blended part.",
        "name": "environmentBRDFTexture",
        "type": "Nullable"
      },
      {
        "comment": "Force normal to face away from face.",
        "name": "forceNormalForward",
        "type": "Boolean"
      },
      {
        "comment": "Enables specular anti aliasing in the PBR shader.\nIt will both interacts on the Geometry for analytical and IBL lighting.\nIt also prefilter the roughness map based on the bump values.",
        "name": "enableSpecularAntiAliasing",
        "type": "Boolean"
      },
      {
        "comment": "This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\nmakes the reflect vector face the model (under horizon).",
        "name": "useHorizonOcclusion",
        "type": "Boolean"
      },
      {
        "comment": "This parameters will enable/disable radiance occlusion by preventing the radiance to lit\ntoo much the area relying on ambient texture to define their ambient occlusion.",
        "name": "useRadianceOcclusion",
        "type": "Boolean"
      },
      {
        "comment": "If set to true, no lighting calculations will be applied.",
        "name": "unlit",
        "type": "Boolean"
      },
      {
        "comment": "Gets the image processing configuration used either in this material.",
        "name": "imageProcessingConfiguration",
        "type": "ImageProcessingConfiguration"
      },
      {
        "comment": "Gets wether the color curves effect is enabled.",
        "name": "cameraColorCurvesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets wether the color grading effect is enabled.",
        "name": "cameraColorGradingEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets wether tonemapping is enabled or not.",
        "name": "cameraToneMappingEnabled",
        "type": "Boolean"
      },
      {
        "comment": "The camera exposure used on this material.\nThis property is here and not in the camera to allow controlling exposure without full screen post process.\nThis corresponds to a photographic exposure.",
        "name": "cameraExposure",
        "type": "Number"
      },
      {
        "comment": "Gets The camera contrast used on this material.",
        "name": "cameraContrast",
        "type": "Number"
      },
      {
        "comment": "Gets the Color Grading 2D Lookup Texture.",
        "name": "cameraColorGradingTexture",
        "type": "Nullable"
      },
      {
        "comment": "The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\nThey allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\nThese are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\ncorresponding to low luminance, medium luminance, and high luminance areas respectively.",
        "name": "cameraColorCurves",
        "type": "Nullable"
      }
    ]
  },
  "PBRMetallicRoughnessMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "The PBR material of BJS following the metal roughness convention.\n\nThis fits to the PBR convention in the GLTF definition:\nhttps://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0",
    "family": "materials",
    "name": "PBRMetallicRoughnessMaterial",
    "props": [
      {
        "comment": "The base color has two different interpretations depending on the value of metalness.\nWhen the material is a metal, the base color is the specific measured reflectance value\nat normal incidence (F0). For a non-metal the base color represents the reflected diffuse color\nof the material.",
        "name": "baseColor",
        "type": "Color3"
      },
      {
        "comment": "Base texture of the metallic workflow. It contains both the baseColor information in RGB as\nwell as opacity information in the alpha channel.",
        "name": "baseTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Specifies the metallic scalar value of the material.\nCan also be used to scale the metalness values of the metallic texture.",
        "name": "metallic",
        "type": "Number"
      },
      {
        "comment": "Specifies the roughness scalar value of the material.\nCan also be used to scale the roughness values of the metallic texture.",
        "name": "roughness",
        "type": "Number"
      },
      {
        "comment": "Texture containing both the metallic value in the B channel and the\nroughness value in the G channel to keep better precision.",
        "name": "metallicRoughnessTexture",
        "type": "BaseTexture"
      }
    ]
  },
  "PBRSpecularGlossinessMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "The PBR material of BJS following the specular glossiness convention.\n\nThis fits to the PBR convention in the GLTF definition:\nhttps://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness",
    "family": "materials",
    "name": "PBRSpecularGlossinessMaterial",
    "props": [
      {
        "comment": "Specifies the diffuse color of the material.",
        "name": "diffuseColor",
        "type": "Color3"
      },
      {
        "comment": "Specifies the diffuse texture of the material. This can also contains the opcity value in its alpha\nchannel.",
        "name": "diffuseTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Specifies the specular color of the material. This indicates how reflective is the material (none to mirror).",
        "name": "specularColor",
        "type": "Color3"
      },
      {
        "comment": "Specifies the glossiness of the material. This indicates \"how sharp is the reflection\".",
        "name": "glossiness",
        "type": "Number"
      },
      {
        "comment": "Specifies both the specular color RGB and the glossiness A of the material per pixels.",
        "name": "specularGlossinessTexture",
        "type": "BaseTexture"
      }
    ]
  },
  "Plane": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a plane mesh\n* The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\n* You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\n* The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreatePlane",
    "options": [
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "width",
        "type": "Number"
      },
      {
        "name": "height",
        "type": "Number"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sourcePlane",
        "type": "Plane"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "PointLight": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "A point light is a light defined by an unique point in world space.\nThe light is emitted in every direction from this point.\nA good example of a point light is a standard light bulb.\nDocumentation: https://doc.babylonjs.com/babylon101/lights",
    "family": "lights",
    "name": "PointLight",
    "props": [
      {
        "comment": "Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\nThis specifies what angle the shadow will use to be created.\n\nIt default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.",
        "name": "shadowAngle",
        "type": "Number"
      },
      {
        "comment": "Gets the direction if it has been set.\nIn case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback",
        "name": "direction",
        "type": "Vector3"
      }
    ]
  },
  "Polygon": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a polygon mesh\nThe polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\n* The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\n* You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\n* Remember you can only change the shape positions, not their number when updating a polygon",
    "family": "meshes",
    "name": "CreatePolygon",
    "options": [
      {
        "name": "shape",
        "type": [
          "Vector3"
        ]
      },
      {
        "name": "holes",
        "type": [
          [
            "Vector3"
          ]
        ]
      },
      {
        "name": "depth",
        "type": "Number"
      },
      {
        "name": "faceUV",
        "type": [
          "Vector4"
        ]
      },
      {
        "name": "faceColors",
        "type": [
          "Color4"
        ]
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "Polyhedron": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a polyhedron mesh\n* The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\n* The parameter `size` (positive float, default 1) sets the polygon size\n* You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\n* You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`\n* A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\n* You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\n* To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors\n* The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreatePolyhedron",
    "options": [
      {
        "name": "type",
        "type": "Number"
      },
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "sizeX",
        "type": "Number"
      },
      {
        "name": "sizeY",
        "type": "Number"
      },
      {
        "name": "sizeZ",
        "type": "Number"
      },
      {
        "name": "custom",
        "type": "Any"
      },
      {
        "name": "faceUV",
        "type": [
          "Vector4"
        ]
      },
      {
        "name": "faceColors",
        "type": [
          "Color4"
        ]
      },
      {
        "name": "flat",
        "type": "Boolean"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "PositionNormalTextureVertex": {
    "args": [
      {
        "comment": "the position of the vertex (defaut: 0,0,0)",
        "name": "position",
        "type": "Vector3"
      },
      {
        "comment": "the normal of the vertex (defaut: 0,1,0)",
        "name": "normal",
        "type": "Vector3"
      },
      {
        "comment": "the uv of the vertex (default: 0,0)",
        "name": "uv",
        "type": "Vector2"
      }
    ],
    "comment": "Contains position, normal and uv vectors for a vertex",
    "family": "materials",
    "name": "PositionNormalTextureVertex",
    "props": [
      {
        "comment": "the position of the vertex (defaut: 0,0,0)",
        "name": "position",
        "type": "Vector3"
      },
      {
        "comment": "the normal of the vertex (defaut: 0,1,0)",
        "name": "normal",
        "type": "Vector3"
      },
      {
        "comment": "the uv of the vertex (default: 0,0)",
        "name": "uv",
        "type": "Vector2"
      }
    ]
  },
  "ProceduralTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "size",
        "type": "Any"
      },
      {
        "name": "fragment",
        "type": "Any"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "fallbackTexture",
        "type": "Nullable"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "isCube",
        "type": "Boolean"
      }
    ],
    "comment": "Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\nThis is the base class of any Procedural texture and contains most of the shareable code.",
    "family": "materials",
    "name": "ProceduralTexture",
    "props": [
      {
        "name": "isCube",
        "type": "Boolean"
      },
      {
        "comment": "Define if the texture is enabled or not (disabled texture will not render)",
        "name": "isEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Define if the texture must be cleared before rendering (default is true)",
        "name": "autoClear",
        "type": "Boolean"
      },
      {
        "comment": "Callback called when the texture is generated",
        "name": "onGenerated",
        "type": "Function"
      },
      {
        "comment": "Event raised when the texture is generated",
        "name": "onGeneratedObservable",
        "type": "Observable"
      },
      {
        "comment": "Define the refresh rate of the texture or the rendering frequency.\nUse 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...",
        "name": "refreshRate",
        "type": "Number"
      }
    ]
  },
  "ProceduralTextureSceneComponent": {
    "args": [
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Defines the Procedural Texture scene component responsible to manage any Procedural Texture\nin a given scene.",
    "family": "materials",
    "name": "ProceduralTextureSceneComponent",
    "props": [
      {
        "comment": "The component name helpfull to identify the component in the list of scene components.",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "The scene the component belongs to.",
        "name": "scene",
        "type": "Scene"
      }
    ]
  },
  "PushMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Base class of materials working in push mode in babylon JS",
    "family": "materials",
    "name": "PushMaterial",
    "props": []
  },
  "RawCubeTexture": {
    "args": [
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "data",
        "type": "Nullable"
      },
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "format",
        "type": "Number"
      },
      {
        "name": "type",
        "type": "Number"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "invertY",
        "type": "Boolean"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "compression",
        "type": "Nullable"
      }
    ],
    "comment": "Raw cube texture where the raw buffers are passed in",
    "family": "materials",
    "name": "RawCubeTexture",
    "props": []
  },
  "RawTexture": {
    "args": [
      {
        "name": "data",
        "type": "ArrayBufferView"
      },
      {
        "name": "width",
        "type": "Number"
      },
      {
        "name": "height",
        "type": "Number"
      },
      {
        "comment": "Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)",
        "name": "format",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "invertY",
        "type": "Boolean"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "type",
        "type": "Number"
      }
    ],
    "comment": "Raw texture can help creating a texture directly from an array of data.\nThis can be super useful if you either get the data from an uncompressed source or\nif you wish to create your texture pixel by pixel.",
    "family": "materials",
    "name": "RawTexture",
    "props": [
      {
        "comment": "Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)",
        "name": "format",
        "type": "Number"
      }
    ]
  },
  "RawTexture3D": {
    "args": [
      {
        "name": "data",
        "type": "ArrayBufferView"
      },
      {
        "name": "width",
        "type": "Number"
      },
      {
        "name": "height",
        "type": "Number"
      },
      {
        "name": "depth",
        "type": "Number"
      },
      {
        "comment": "Gets or sets the texture format to use",
        "name": "format",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "invertY",
        "type": "Boolean"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "textureType",
        "type": "Number"
      }
    ],
    "comment": "Class used to store 3D textures containing user data",
    "family": "materials",
    "name": "RawTexture3D",
    "props": [
      {
        "comment": "Gets or sets the texture format to use",
        "name": "format",
        "type": "Number"
      }
    ]
  },
  "RefractionTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "size",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      }
    ],
    "comment": "Creates a refraction texture used by refraction channel of the standard material.\nIt is like a mirror but to see through a material.",
    "family": "materials",
    "name": "RefractionTexture",
    "props": [
      {
        "comment": "Define the reflection plane we want to use. The refractionPlane is usually set to the constructed refractor.\nIt is possible to directly set the refractionPlane by directly using a BABYLON.Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the refractionPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the refractor as stated in the doc.",
        "name": "refractionPlane",
        "type": "Plane"
      },
      {
        "comment": "Define how deep under the surface we should see.",
        "name": "depth",
        "type": "Number"
      }
    ]
  },
  "RenderTargetTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "size",
        "type": "Union"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "doNotChangeAspectRatio",
        "type": "Boolean"
      },
      {
        "name": "type",
        "type": "Number"
      },
      {
        "name": "isCube",
        "type": "Boolean"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "generateDepthBuffer",
        "type": "Boolean"
      },
      {
        "name": "generateStencilBuffer",
        "type": "Boolean"
      },
      {
        "name": "isMulti",
        "type": "Boolean"
      },
      {
        "name": "format",
        "type": "Number"
      }
    ],
    "comment": "This Helps creating a texture that will be created from a camera in your scene.\nIt is basically a dynamic texture that could be used to create special effects for instance.\nActually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...",
    "family": "materials",
    "name": "RenderTargetTexture",
    "props": [
      {
        "name": "isCube",
        "type": "Boolean"
      },
      {
        "comment": "Use this predicate to dynamically define the list of mesh you want to render.\nIf set, the renderList property will be overwritten.",
        "name": "renderListPredicate",
        "type": "Function"
      },
      {
        "comment": "Use this list to define the list of mesh you want to render.",
        "name": "renderList",
        "type": "Nullable"
      },
      {
        "comment": "Define if particles should be rendered in your texture.",
        "name": "renderParticles",
        "type": "Boolean"
      },
      {
        "comment": "Define if sprites should be rendered in your texture.",
        "name": "renderSprites",
        "type": "Boolean"
      },
      {
        "comment": "Override the default coordinates mode to projection for RTT as it is the most common case for rendered textures.",
        "name": "coordinatesMode",
        "type": "Number"
      },
      {
        "comment": "Define the camera used to render the texture.",
        "name": "activeCamera",
        "type": "Nullable"
      },
      {
        "comment": "Override the render function of the texture with your own one.",
        "name": "customRenderFunction",
        "type": "Function"
      },
      {
        "comment": "Define if camera post processes should be use while rendering the texture.",
        "name": "useCameraPostProcesses",
        "type": "Boolean"
      },
      {
        "comment": "Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.",
        "name": "ignoreCameraViewport",
        "type": "Boolean"
      },
      {
        "comment": "An event triggered when the texture is unbind.",
        "name": "onBeforeBindObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when the texture is unbind.",
        "name": "onAfterUnbindObservable",
        "type": "Observable"
      },
      {
        "comment": "Set a after unbind callback in the texture.\nThis has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.",
        "name": "onAfterUnbind",
        "type": "Function"
      },
      {
        "comment": "An event triggered before rendering the texture",
        "name": "onBeforeRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "Set a before render callback in the texture.\nThis has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.",
        "name": "onBeforeRender",
        "type": "Function"
      },
      {
        "comment": "An event triggered after rendering the texture",
        "name": "onAfterRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "Set a after render callback in the texture.\nThis has been kept for backward compatibility and use of onAfterRenderObservable is recommended.",
        "name": "onAfterRender",
        "type": "Function"
      },
      {
        "comment": "An event triggered after the texture clear",
        "name": "onClearObservable",
        "type": "Observable"
      },
      {
        "comment": "Set a clear callback in the texture.\nThis has been kept for backward compatibility and use of onClearObservable is recommended.",
        "name": "onClear",
        "type": "Function"
      },
      {
        "comment": "Define the clear color of the Render Target if it should be different from the scene.",
        "name": "clearColor",
        "type": "Color4"
      },
      {
        "comment": "Gets render target creation options that were used.",
        "name": "renderTargetOptions",
        "type": "RenderTargetCreationOptions"
      },
      {
        "comment": "Gets or sets the center of the bounding box associated with the texture (when in cube mode)\nIt must define where the camera used to render the texture is set",
        "name": "boundingBoxPosition",
        "type": "Vector3"
      },
      {
        "comment": "Gets or sets the size of the bounding box associated with the texture (when in cube mode)\nWhen defined, the cubemap will switch to local mode",
        "name": "boundingBoxSize",
        "type": "Vector3"
      },
      {
        "comment": "In case the RTT has been created with a depth texture, get the associated\ndepth texture.\nOtherwise, return null.",
        "name": "depthStencilTexture",
        "type": "Nullable"
      },
      {
        "comment": "Define the number of samples to use in case of MSAA.\nIt defaults to one meaning no MSAA has been enabled.",
        "name": "samples",
        "type": "Number"
      },
      {
        "comment": "Define the refresh rate of the texture or the rendering frequency.\nUse 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...",
        "name": "refreshRate",
        "type": "Number"
      },
      {
        "comment": "Get if the texture can be rescaled or not.",
        "name": "canRescale",
        "type": "Boolean"
      },
      {
        "name": "renderToTarget"
      }
    ]
  },
  "Ribbon": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\n* The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\n* The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\n* The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\n* The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\n* It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\n* The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n* The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\n* The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\n* Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\n* Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateRibbon",
    "options": [
      {
        "name": "pathArray",
        "type": [
          [
            "Vector3"
          ]
        ]
      },
      {
        "name": "closeArray",
        "type": "Boolean"
      },
      {
        "name": "closePath",
        "type": "Boolean"
      },
      {
        "name": "offset",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      },
      {
        "name": "instance",
        "type": "Mesh"
      },
      {
        "name": "invertUV",
        "type": "Boolean"
      },
      {
        "name": "uvs",
        "type": [
          "Vector2"
        ]
      },
      {
        "name": "colors",
        "type": [
          "Color4"
        ]
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "Scene": {
    "args": [
      {
        "name": "engine",
        "type": "Engine"
      }
    ],
    "comment": "Represents a scene to be rendered by the engine.",
    "family": "system",
    "name": "Scene",
    "props": [
      {
        "comment": "Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame",
        "name": "autoClear",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame",
        "name": "autoClearDepthAndStencil",
        "type": "Boolean"
      },
      {
        "comment": "Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))",
        "name": "clearColor",
        "type": "Color4"
      },
      {
        "comment": "Defines the color used to simulate the ambient color (Default is (0, 0, 0))",
        "name": "ambientColor",
        "type": "Color3"
      },
      {
        "comment": "Texture used in all pbr material as the reflection texture.\nAs in the majority of the scene they are the same (exception for multi room and so on),\nthis is easier to reference from here than from all the materials.",
        "name": "environmentTexture",
        "type": "BaseTexture"
      },
      {
        "comment": "Default image processing configuration used either in the rendering\nForward main pass or through the imageProcessingPostProcess if present.\nAs in the majority of the scene they are the same (exception for multi camera),\nthis is easier to reference from here than from all the materials and post process.\n\nNo setter as we it is a shared configuration, you can set the values instead.",
        "name": "imageProcessingConfiguration",
        "type": "ImageProcessingConfiguration"
      },
      {
        "comment": "Gets or sets a boolean indicating if all rendering must be done in wireframe",
        "name": "forceWireframe",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if all rendering must be done in point cloud",
        "name": "forcePointsCloud",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets the active clipplane 1",
        "name": "clipPlane",
        "type": "Nullable"
      },
      {
        "comment": "Gets or sets the active clipplane 2",
        "name": "clipPlane2",
        "type": "Nullable"
      },
      {
        "comment": "Gets or sets the active clipplane 3",
        "name": "clipPlane3",
        "type": "Nullable"
      },
      {
        "comment": "Gets or sets the active clipplane 4",
        "name": "clipPlane4",
        "type": "Nullable"
      },
      {
        "comment": "Gets or sets a boolean indicating if animations are enabled",
        "name": "animationsEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets the animation properties override",
        "name": "animationPropertiesOverride",
        "type": "Nullable"
      },
      {
        "comment": "Gets or sets a boolean indicating if a constant deltatime has to be used\nThis is mostly useful for testing purposes when you do not want the animations to scale with the framerate",
        "name": "useConstantAnimationDeltaTime",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\nPlease note that it requires to run a ray cast through the scene on every frame",
        "name": "constantlyUpdateMeshUnderPointer",
        "type": "Boolean"
      },
      {
        "comment": "Defines the HTML cursor to use when hovering over interactive elements",
        "name": "hoverCursor",
        "type": "String"
      },
      {
        "comment": "Defines the HTML default cursor to use (empty by default)",
        "name": "defaultCursor",
        "type": "String"
      },
      {
        "comment": "This is used to call preventDefault() on pointer down\nin order to block unwanted artifacts like system double clicks",
        "name": "preventDefaultOnPointerDown",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets user defined metadata",
        "name": "metadata",
        "type": "Any"
      },
      {
        "comment": "Gets the name of the plugin used to load this scene (null by default)",
        "name": "loadingPluginName",
        "type": "String"
      },
      {
        "comment": "Use this array to add regular expressions used to disable offline support for specific urls",
        "name": "disableOfflineSupportExceptionRules",
        "type": [
          "RegExp"
        ]
      },
      {
        "comment": "An event triggered when the scene is disposed.",
        "name": "onDisposeObservable",
        "type": "Observable"
      },
      {
        "comment": "Sets a function to be executed when this scene is disposed.",
        "name": "onDispose",
        "type": "Function"
      },
      {
        "comment": "An event triggered before rendering the scene (right after animations and physics)",
        "name": "onBeforeRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "Sets a function to be executed before rendering this scene",
        "name": "beforeRender",
        "type": "Nullable"
      },
      {
        "comment": "An event triggered after rendering the scene",
        "name": "onAfterRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "Sets a function to be executed after rendering this scene",
        "name": "afterRender",
        "type": "Nullable"
      },
      {
        "comment": "An event triggered before animating the scene",
        "name": "onBeforeAnimationsObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered after animations processing",
        "name": "onAfterAnimationsObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered before draw calls are ready to be sent",
        "name": "onBeforeDrawPhaseObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered after draw calls have been sent",
        "name": "onAfterDrawPhaseObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when the scene is ready",
        "name": "onReadyObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered before rendering a camera",
        "name": "onBeforeCameraRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "Sets a function to be executed before rendering a camera",
        "name": "beforeCameraRender",
        "type": "Function"
      },
      {
        "comment": "An event triggered after rendering a camera",
        "name": "onAfterCameraRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "Sets a function to be executed after rendering a camera",
        "name": "afterCameraRender",
        "type": "Function"
      },
      {
        "comment": "An event triggered when active meshes evaluation is about to start",
        "name": "onBeforeActiveMeshesEvaluationObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when active meshes evaluation is done",
        "name": "onAfterActiveMeshesEvaluationObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when particles rendering is about to start\nNote: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)",
        "name": "onBeforeParticlesRenderingObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when particles rendering is done\nNote: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)",
        "name": "onAfterParticlesRenderingObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed",
        "name": "onDataLoadedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a camera is created",
        "name": "onNewCameraAddedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a camera is removed",
        "name": "onCameraRemovedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a light is created",
        "name": "onNewLightAddedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a light is removed",
        "name": "onLightRemovedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a geometry is created",
        "name": "onNewGeometryAddedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a geometry is removed",
        "name": "onGeometryRemovedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a transform node is created",
        "name": "onNewTransformNodeAddedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a transform node is removed",
        "name": "onTransformNodeRemovedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a mesh is created",
        "name": "onNewMeshAddedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a mesh is removed",
        "name": "onMeshRemovedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a material is created",
        "name": "onNewMaterialAddedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a material is removed",
        "name": "onMaterialRemovedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a texture is created",
        "name": "onNewTextureAddedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when a texture is removed",
        "name": "onTextureRemovedObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when render targets are about to be rendered\nCan happen multiple times per frame.",
        "name": "onBeforeRenderTargetsRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered when render targets were rendered.\nCan happen multiple times per frame.",
        "name": "onAfterRenderTargetsRenderObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered before calculating deterministic simulation step",
        "name": "onBeforeStepObservable",
        "type": "Observable"
      },
      {
        "comment": "An event triggered after calculating deterministic simulation step",
        "name": "onAfterStepObservable",
        "type": "Observable"
      },
      {
        "comment": "This Observable will be triggered before rendering each renderingGroup of each rendered camera.\nThe RenderinGroupInfo class contains all the information about the context in which the observable is called\nIf you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)",
        "name": "onBeforeRenderingGroupObservable",
        "type": "Observable"
      },
      {
        "comment": "This Observable will be triggered after rendering each renderingGroup of each rendered camera.\nThe RenderinGroupInfo class contains all the information about the context in which the observable is called\nIf you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)",
        "name": "onAfterRenderingGroupObservable",
        "type": "Observable"
      },
      {
        "comment": "This Observable will when a mesh has been imported into the scene.",
        "name": "onMeshImportedObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets or sets a predicate used to select candidate meshes for a pointer down event",
        "name": "pointerDownPredicate",
        "type": "Function"
      },
      {
        "comment": "Gets or sets a predicate used to select candidate meshes for a pointer up event",
        "name": "pointerUpPredicate",
        "type": "Function"
      },
      {
        "comment": "Gets or sets a predicate used to select candidate meshes for a pointer move event",
        "name": "pointerMovePredicate",
        "type": "Function"
      },
      {
        "comment": "Deprecated. Use onPointerObservable instead",
        "name": "onPointerMove",
        "type": "Function"
      },
      {
        "comment": "Deprecated. Use onPointerObservable instead",
        "name": "onPointerDown",
        "type": "Function"
      },
      {
        "comment": "Deprecated. Use onPointerObservable instead",
        "name": "onPointerUp",
        "type": "Function"
      },
      {
        "comment": "Deprecated. Use onPointerObservable instead",
        "name": "onPointerPick",
        "type": "Function"
      },
      {
        "comment": "This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\nYou have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true",
        "name": "onPrePointerObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable event triggered each time an input event is received from the rendering canvas",
        "name": "onPointerObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets the pointer coordinates without any translation (ie. straight out of the pointer event)",
        "name": "unTranslatedPointer",
        "type": "Vector2"
      },
      {
        "comment": "Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position",
        "name": "cameraToUseForPointers",
        "type": "Nullable"
      },
      {
        "comment": "This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\nYou have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true",
        "name": "onPreKeyboardObservable",
        "type": "Observable"
      },
      {
        "comment": "Observable event triggered each time an keyboard event is received from the hosting window",
        "name": "onKeyboardObservable",
        "type": "Observable"
      },
      {
        "comment": "Gets or sets a boolean indicating if the scene must use right-handed coordinates system",
        "name": "useRightHandedSystem",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if fog is enabled on this scene",
        "name": "fogEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets the fog mode to use",
        "name": "fogMode",
        "type": "Number"
      },
      {
        "comment": "Gets or sets the fog color to use",
        "name": "fogColor",
        "type": "Color3"
      },
      {
        "comment": "Gets or sets the fog density to use",
        "name": "fogDensity",
        "type": "Number"
      },
      {
        "comment": "Gets or sets the fog start distance to use",
        "name": "fogStart",
        "type": "Number"
      },
      {
        "comment": "Gets or sets the fog end distance to use",
        "name": "fogEnd",
        "type": "Number"
      },
      {
        "comment": "Gets or sets a boolean indicating if shadows are enabled on this scene",
        "name": "shadowsEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if lights are enabled on this scene",
        "name": "lightsEnabled",
        "type": "Boolean"
      },
      {
        "comment": "All of the active cameras added to this scene.",
        "name": "activeCameras",
        "type": [
          "Camera"
        ]
      },
      {
        "comment": "The current active camera",
        "name": "activeCamera",
        "type": "Nullable"
      },
      {
        "comment": "The default material used on meshes when no material is affected",
        "name": "defaultMaterial",
        "type": "Material"
      },
      {
        "comment": "Gets or sets a boolean indicating if textures are enabled on this scene",
        "name": "texturesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if particles are enabled on this scene",
        "name": "particlesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if sprites are enabled on this scene",
        "name": "spritesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if skeletons are enabled on this scene",
        "name": "skeletonsEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if lens flares are enabled on this scene",
        "name": "lensFlaresEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if collisions are enabled on this scene",
        "name": "collisionsEnabled",
        "type": "Boolean"
      },
      {
        "name": "collisionCoordinator",
        "type": "ICollisionCoordinator"
      },
      {
        "comment": "Defines the gravity applied to this scene (used only for collisions)",
        "name": "gravity",
        "type": "Vector3"
      },
      {
        "comment": "Gets or sets a boolean indicating if postprocesses are enabled on this scene",
        "name": "postProcessesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "The list of postprocesses added to the scene",
        "name": "postProcesses",
        "type": [
          "PostProcess"
        ]
      },
      {
        "comment": "Gets the current postprocess manager",
        "name": "postProcessManager",
        "type": "PostProcessManager"
      },
      {
        "comment": "Gets or sets a boolean indicating if render targets are enabled on this scene",
        "name": "renderTargetsEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\nWe recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com",
        "name": "dumpNextRenderTargets",
        "type": "Boolean"
      },
      {
        "comment": "The list of user defined render targets added to the scene",
        "name": "customRenderTargets",
        "type": [
          "RenderTargetTexture"
        ]
      },
      {
        "comment": "Defines if texture loading must be delayed\nIf true, textures will only be loaded when they need to be rendered",
        "name": "useDelayedTextureLoading",
        "type": "Boolean"
      },
      {
        "comment": "Gets the list of meshes imported to the scene through SceneLoader",
        "name": "importedMeshesFiles",
        "type": [
          "String"
        ]
      },
      {
        "comment": "Gets or sets a boolean indicating if probes are enabled on this scene",
        "name": "probesEnabled",
        "type": "Boolean"
      },
      {
        "name": "database",
        "type": "Database"
      },
      {
        "comment": "Gets or sets the action manager associated with the scene",
        "name": "actionManager",
        "type": "ActionManager"
      },
      {
        "comment": "Gets or sets a boolean indicating if procedural textures are enabled on this scene",
        "name": "proceduralTexturesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a general scale for animation speed",
        "name": "animationTimeScale",
        "type": "Number"
      },
      {
        "comment": "Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\nUse this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)",
        "name": "dispatchAllSubMeshesOfActiveMeshes",
        "type": "Boolean"
      },
      {
        "comment": "Gets the list of frustum planes (built from the active camera)",
        "name": "frustumPlanes",
        "type": [
          "Plane"
        ]
      },
      {
        "comment": "Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\nThis is useful if there are more lights that the maximum simulteanous authorized",
        "name": "requireLightSorting",
        "type": "Boolean"
      },
      {
        "comment": "Gets a boolean indicating if collisions are processed on a web worker",
        "name": "workerCollisions",
        "type": "Boolean"
      },
      {
        "comment": "Gets the mesh that is currently under the pointer",
        "name": "meshUnderPointer",
        "type": "Nullable"
      },
      {
        "comment": "Gets the current on-screen X position of the pointer",
        "name": "pointerX",
        "type": "Number"
      },
      {
        "comment": "Gets the current on-screen Y position of the pointer",
        "name": "pointerY",
        "type": "Number"
      },
      {
        "comment": "Gets the performance counter for total vertices",
        "name": "totalVerticesPerfCounter",
        "type": "PerfCounter"
      },
      {
        "comment": "Gets the performance counter for active indices",
        "name": "totalActiveIndicesPerfCounter",
        "type": "PerfCounter"
      },
      {
        "comment": "Gets the performance counter for active particles",
        "name": "activeParticlesPerfCounter",
        "type": "PerfCounter"
      },
      {
        "comment": "Gets the performance counter for active bones",
        "name": "activeBonesPerfCounter",
        "type": "PerfCounter"
      },
      {
        "name": "interFramePerfCounter",
        "type": "Nullable"
      },
      {
        "name": "lastFramePerfCounter",
        "type": "Nullable"
      },
      {
        "name": "evaluateActiveMeshesDurationPerfCounter",
        "type": "Nullable"
      },
      {
        "name": "renderDurationPerfCounter",
        "type": "Nullable"
      },
      {
        "name": "particlesDurationPerfCounter",
        "type": "Nullable"
      },
      {
        "name": "spriteDuractionPerfCounter",
        "type": "Nullable"
      },
      {
        "comment": "Returns a boolean indicating if the scene is still loading data",
        "name": "isLoading",
        "type": "Boolean"
      },
      {
        "comment": "Gets all animatable attached to the scene",
        "name": "animatables",
        "type": [
          "Animatable"
        ]
      },
      {
        "comment": "Return a unique id as a string which can serve as an identifier for the scene",
        "name": "uid",
        "type": "String"
      },
      {
        "comment": "Lambda returning the list of potentially active meshes.",
        "name": "getActiveMeshCandidates",
        "type": "Function"
      },
      {
        "comment": "Lambda returning the list of potentially active sub meshes.",
        "name": "getActiveSubMeshCandidates",
        "type": "Function"
      },
      {
        "comment": "Lambda returning the list of potentially intersecting sub meshes.",
        "name": "getIntersectingSubMeshCandidates",
        "type": "Function"
      },
      {
        "comment": "Lambda returning the list of potentially colliding sub meshes.",
        "name": "getCollidingSubMeshCandidates",
        "type": "Function"
      },
      {
        "comment": "User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode",
        "name": "getDeterministicFrameTime",
        "type": "Function"
      },
      {
        "comment": "Gets if the scene is already disposed",
        "name": "isDisposed",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync)",
        "name": "blockMaterialDirtyMechanism",
        "type": "Boolean"
      }
    ]
  },
  "ShaderMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "shaderPath",
        "type": "Any"
      },
      {
        "name": "options",
        "type": "Partial"
      }
    ],
    "comment": "The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\n\nThis returned material effects how the mesh will look based on the code in the shaders.",
    "family": "materials",
    "name": "ShaderMaterial",
    "props": []
  },
  "ShadowLight": {
    "args": [],
    "comment": "Base implementation IShadowLight\nIt groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.",
    "family": "lights",
    "name": "ShadowLight",
    "props": [
      {
        "comment": "Sets the position the shadow will be casted from. Also use as the light position for both\npoint and spot lights.",
        "name": "position",
        "type": "Vector3"
      },
      {
        "comment": "In 2d mode (needCube being false), gets the direction used to cast the shadow.\nAlso use as the light direction on spot and directional lights.",
        "name": "direction",
        "type": "Vector3"
      },
      {
        "comment": "Gets the shadow projection clipping minimum z value.",
        "name": "shadowMinZ",
        "type": "Number"
      },
      {
        "comment": "Sets the shadow projection clipping maximum z value.",
        "name": "shadowMaxZ",
        "type": "Number"
      },
      {
        "comment": "Callback defining a custom Projection Matrix Builder.\nThis can be used to override the default projection matrix computation.",
        "name": "customProjectionMatrixBuilder",
        "type": "Function"
      },
      {
        "comment": "The transformed position. Position of the light in world space taking parenting in account.",
        "name": "transformedPosition",
        "type": "Vector3"
      },
      {
        "comment": "The transformed direction. Direction of the light in world space taking parenting in account.",
        "name": "transformedDirection",
        "type": "Vector3"
      }
    ]
  },
  "Sphere": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a sphere mesh\n* The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\n* You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\n* The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\n* You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\n* You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateSphere",
    "options": [
      {
        "name": "segments",
        "type": "Number"
      },
      {
        "name": "diameter",
        "type": "Number"
      },
      {
        "name": "diameterX",
        "type": "Number"
      },
      {
        "name": "diameterY",
        "type": "Number"
      },
      {
        "name": "diameterZ",
        "type": "Number"
      },
      {
        "name": "arc",
        "type": "Number"
      },
      {
        "name": "slice",
        "type": "Number"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "SpotLight": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "direction",
        "type": "Vector3"
      },
      {
        "name": "angle",
        "type": "Number"
      },
      {
        "name": "exponent",
        "type": "Number"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "A spot light is defined by a position, a direction, an angle, and an exponent.\nThese values define a cone of light starting from the position, emitting toward the direction.\nThe angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,\nand the exponent defines the speed of the decay of the light with distance (reach).\nDocumentation: https://doc.babylonjs.com/babylon101/lights",
    "family": "lights",
    "name": "SpotLight",
    "props": [
      {
        "comment": "Gets the cone angle of the spot light in Radians.",
        "name": "angle",
        "type": "Number"
      },
      {
        "comment": "Only used in gltf falloff mode, this defines the angle where\nthe directional falloff will start before cutting at angle which could be seen\nas outer angle.",
        "name": "innerAngle",
        "type": "Number"
      },
      {
        "comment": "Allows scaling the angle of the light for shadow generation only.",
        "name": "shadowAngleScale",
        "type": "Number"
      },
      {
        "comment": "The light decay speed with the distance from the emission spot.",
        "name": "exponent",
        "type": "Number"
      },
      {
        "comment": "Allows reading the projecton texture",
        "name": "projectionTextureMatrix",
        "type": "Matrix"
      },
      {
        "comment": "Gets the near clip of the Spotlight for texture projection.",
        "name": "projectionTextureLightNear",
        "type": "Number"
      },
      {
        "comment": "Gets the far clip of the Spotlight for texture projection.",
        "name": "projectionTextureLightFar",
        "type": "Number"
      },
      {
        "comment": "Gets the Up vector of the Spotlight for texture projection.",
        "name": "projectionTextureUpDirection",
        "type": "Vector3"
      },
      {
        "comment": "Gets the projection texture of the light.",
        "name": "projectionTexture",
        "type": "Nullable"
      }
    ]
  },
  "Sprite": {
    "args": [
      {
        "comment": "defines the name",
        "name": "name",
        "type": "string"
      },
      {
        "name": "manager",
        "type": "ISpriteManager"
      }
    ],
    "comment": "Class used to represent a sprite",
    "family": "materials",
    "name": "Sprite",
    "props": [
      {
        "comment": "defines the name",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Gets or sets the current world position",
        "name": "position",
        "type": "Vector3"
      },
      {
        "comment": "Gets or sets the main color",
        "name": "color",
        "type": "Color4"
      },
      {
        "comment": "Gets or sets the width",
        "name": "width",
        "type": "Number"
      },
      {
        "comment": "Gets or sets the height",
        "name": "height",
        "type": "Number"
      },
      {
        "comment": "Gets or sets rotation angle",
        "name": "angle",
        "type": "Number"
      },
      {
        "comment": "Gets or sets the cell index in the sprite sheet",
        "name": "cellIndex",
        "type": "Number"
      },
      {
        "comment": "Gets or sets a boolean indicating if UV coordinates should be inverted in U axis",
        "name": "invertU",
        "type": "Number"
      },
      {
        "comment": "Gets or sets a boolean indicating if UV coordinates should be inverted in B axis",
        "name": "invertV",
        "type": "Number"
      },
      {
        "comment": "Gets or sets a boolean indicating that this sprite should be disposed after animation ends",
        "name": "disposeWhenFinishedAnimating",
        "type": "Boolean"
      },
      {
        "comment": "Gets the list of attached animations",
        "name": "animations",
        "type": [
          "Animation"
        ]
      },
      {
        "comment": "Gets or sets a boolean indicating if the sprite can be picked",
        "name": "isPickable",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets the associated action manager",
        "name": "actionManager",
        "type": "Nullable"
      },
      {
        "comment": "Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true",
        "name": "isVisible",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets the sprite size",
        "name": "size",
        "type": "Number"
      }
    ]
  },
  "SpriteManager": {
    "args": [
      {
        "comment": "defines the manager's name",
        "name": "name",
        "type": "string"
      },
      {
        "name": "imgUrl",
        "type": "String"
      },
      {
        "name": "capacity",
        "type": "Number"
      },
      {
        "name": "cellSize",
        "type": "Any"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "epsilon",
        "type": "Number"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      }
    ],
    "comment": "Class used to manage multiple sprites on the same spritesheet",
    "family": "materials",
    "name": "SpriteManager",
    "props": [
      {
        "comment": "defines the manager's name",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Gets the list of sprites",
        "name": "sprites",
        "type": [
          "Sprite"
        ]
      },
      {
        "comment": "Gets or sets the rendering group id (0 by default)",
        "name": "renderingGroupId",
        "type": "Number"
      },
      {
        "comment": "Gets or sets camera layer mask",
        "name": "layerMask",
        "type": "Number"
      },
      {
        "comment": "Gets or sets a boolean indicating if the manager must consider scene fog when rendering",
        "name": "fogEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets or sets a boolean indicating if the sprites are pickable",
        "name": "isPickable",
        "type": "Boolean"
      },
      {
        "comment": "Defines the default width of a cell in the spritesheet",
        "name": "cellWidth",
        "type": "Number"
      },
      {
        "comment": "Defines the default height of a cell in the spritesheet",
        "name": "cellHeight",
        "type": "Number"
      },
      {
        "comment": "An event triggered when the manager is disposed.",
        "name": "onDisposeObservable",
        "type": "Observable"
      },
      {
        "comment": "Callback called when the manager is disposed",
        "name": "onDispose",
        "type": "Function"
      },
      {
        "comment": "Gets or sets the spritesheet texture",
        "name": "texture",
        "type": "Texture"
      }
    ]
  },
  "SpriteSceneComponent": {
    "args": [
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Defines the sprite scene component responsible to manage sprites\nin a given scene.",
    "family": "materials",
    "name": "SpriteSceneComponent",
    "props": [
      {
        "comment": "The component name helpfull to identify the component in the list of scene components.",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "The scene the component belongs to.",
        "name": "scene",
        "type": "Scene"
      }
    ]
  },
  "StandardMaterial": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "This is the default material used in Babylon. It is the best trade off between quality\nand performances.",
    "family": "materials",
    "name": "StandardMaterial",
    "props": [
      {
        "comment": "The basic texture of the material as viewed under a light.",
        "name": "diffuseTexture",
        "type": "Nullable"
      },
      {
        "comment": "AKA Occlusion Texture in other nomenclature, it helps adding baked shadows into your material.",
        "name": "ambientTexture",
        "type": "Nullable"
      },
      {
        "comment": "Define the transparency of the material from a texture.\nThe final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false)\nor from the luminance or the current texel (if texture.getAlphaFromRGB is true)",
        "name": "opacityTexture",
        "type": "Nullable"
      },
      {
        "comment": "Define the texture used to display the reflection.",
        "name": "reflectionTexture",
        "type": "Nullable"
      },
      {
        "comment": "Define texture of the material as if self lit.\nThis will be mixed in the final result even in the absence of light.",
        "name": "emissiveTexture",
        "type": "Nullable"
      },
      {
        "comment": "Define how the color and intensity of the highlight given by the light in the material.",
        "name": "specularTexture",
        "type": "Nullable"
      },
      {
        "comment": "Bump mapping is a technique to simulate bump and dents on a rendered surface.\nThese are made by creating a normal map from an image. The means to do this can be found on the web, a search for 'normal map generator' will bring up free and paid for methods of doing this.",
        "name": "bumpTexture",
        "type": "Nullable"
      },
      {
        "comment": "Complex lighting can be computationally expensive to compute at runtime.\nTo save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.",
        "name": "lightmapTexture",
        "type": "Nullable"
      },
      {
        "comment": "Define the texture used to display the refraction.",
        "name": "refractionTexture",
        "type": "Nullable"
      },
      {
        "comment": "The color of the material lit by the environmental background lighting.",
        "name": "ambientColor",
        "type": "Color3"
      },
      {
        "comment": "The basic color of the material as viewed under a light.",
        "name": "diffuseColor",
        "type": "Color3"
      },
      {
        "comment": "Define how the color and intensity of the highlight given by the light in the material.",
        "name": "specularColor",
        "type": "Color3"
      },
      {
        "comment": "Define the color of the material as if self lit.\nThis will be mixed in the final result even in the absence of light.",
        "name": "emissiveColor",
        "type": "Color3"
      },
      {
        "comment": "Defines how sharp are the highlights in the material.\nThe bigger the value the sharper giving a more glossy feeling to the result.\nReversely, the smaller the value the blurrier giving a more rough feeling to the result.",
        "name": "specularPower",
        "type": "Number"
      },
      {
        "comment": "Does the transparency come from the diffuse texture alpha channel.",
        "name": "useAlphaFromDiffuseTexture",
        "type": "Boolean"
      },
      {
        "comment": "If true, the emissive value is added into the end result, otherwise it is multiplied in.",
        "name": "useEmissiveAsIllumination",
        "type": "Boolean"
      },
      {
        "comment": "If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing\nthe emissive level when the final color is close to one.",
        "name": "linkEmissiveWithDiffuse",
        "type": "Boolean"
      },
      {
        "comment": "Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).\nA car glass is a good exemple of that. When sun reflects on it you can not see what is behind.",
        "name": "useSpecularOverAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).\nA car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.",
        "name": "useReflectionOverAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Does lights from the scene impacts this material.\nIt can be a nice trick for performance to disable lighting on a fully emissive material.",
        "name": "disableLighting",
        "type": "Boolean"
      },
      {
        "comment": "Allows using an object space normal map (instead of tangent space).",
        "name": "useObjectSpaceNormalMap",
        "type": "Boolean"
      },
      {
        "comment": "Is parallax enabled or not.",
        "name": "useParallax",
        "type": "Boolean"
      },
      {
        "comment": "Is parallax occlusion enabled or not.\nIf true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.",
        "name": "useParallaxOcclusion",
        "type": "Boolean"
      },
      {
        "comment": "Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.",
        "name": "parallaxScaleBias",
        "type": "Number"
      },
      {
        "comment": "Helps to define how blurry the reflections should appears in the material.",
        "name": "roughness",
        "type": "Number"
      },
      {
        "comment": "In case of refraction, define the value of the indice of refraction.",
        "name": "indexOfRefraction",
        "type": "Number"
      },
      {
        "comment": "Invert the refraction texture alongside the y axis.\nIt can be usefull with procedural textures or probe for instance.",
        "name": "invertRefractionY",
        "type": "Boolean"
      },
      {
        "comment": "Defines the alpha limits in alpha test mode.",
        "name": "alphaCutOff",
        "type": "Number"
      },
      {
        "comment": "In case of light mapping, define whether the map contains light or shadow informations.",
        "name": "useLightmapAsShadowmap",
        "type": "Boolean"
      },
      {
        "comment": "Define the diffuse fresnel parameters of the material.",
        "name": "diffuseFresnelParameters",
        "type": "FresnelParameters"
      },
      {
        "comment": "Define the opacity fresnel parameters of the material.",
        "name": "opacityFresnelParameters",
        "type": "FresnelParameters"
      },
      {
        "comment": "Define the reflection fresnel parameters of the material.",
        "name": "reflectionFresnelParameters",
        "type": "FresnelParameters"
      },
      {
        "comment": "Define the refraction fresnel parameters of the material.",
        "name": "refractionFresnelParameters",
        "type": "FresnelParameters"
      },
      {
        "comment": "Define the emissive fresnel parameters of the material.",
        "name": "emissiveFresnelParameters",
        "type": "FresnelParameters"
      },
      {
        "comment": "If true automatically deducts the fresnels values from the material specularity.",
        "name": "useReflectionFresnelFromSpecular",
        "type": "Boolean"
      },
      {
        "comment": "Defines if the glossiness/roughness of the material should be read from the specular map alpha channel",
        "name": "useGlossinessFromSpecularMapAlpha",
        "type": "Boolean"
      },
      {
        "comment": "Defines the maximum number of lights that can be used in the material",
        "name": "maxSimultaneousLights",
        "type": "Number"
      },
      {
        "comment": "If sets to true, x component of normal map value will invert (x = 1.0 - x).",
        "name": "invertNormalMapX",
        "type": "Boolean"
      },
      {
        "comment": "If sets to true, y component of normal map value will invert (y = 1.0 - y).",
        "name": "invertNormalMapY",
        "type": "Boolean"
      },
      {
        "comment": "If sets to true and backfaceCulling is false, normals will be flipped on the backside.",
        "name": "twoSidedLighting",
        "type": "Boolean"
      },
      {
        "comment": "Gets the image processing configuration used either in this material.",
        "name": "imageProcessingConfiguration",
        "type": "ImageProcessingConfiguration"
      },
      {
        "comment": "Gets wether the color curves effect is enabled.",
        "name": "cameraColorCurvesEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets wether the color grading effect is enabled.",
        "name": "cameraColorGradingEnabled",
        "type": "Boolean"
      },
      {
        "comment": "Gets wether tonemapping is enabled or not.",
        "name": "cameraToneMappingEnabled",
        "type": "Boolean"
      },
      {
        "comment": "The camera exposure used on this material.\nThis property is here and not in the camera to allow controlling exposure without full screen post process.\nThis corresponds to a photographic exposure.",
        "name": "cameraExposure",
        "type": "Number"
      },
      {
        "comment": "Gets The camera contrast used on this material.",
        "name": "cameraContrast",
        "type": "Number"
      },
      {
        "comment": "Gets the Color Grading 2D Lookup Texture.",
        "name": "cameraColorGradingTexture",
        "type": "Nullable"
      },
      {
        "comment": "The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\nThey allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\nThese are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\ncorresponding to low luminance, medium luminance, and high luminance areas respectively.",
        "name": "cameraColorCurves",
        "type": "Nullable"
      },
      {
        "comment": "Custom callback helping to override the default shader used in the material.",
        "name": "customShaderNameResolve",
        "type": "Function"
      },
      {
        "comment": "Gets a boolean indicating that current material needs to register RTT",
        "name": "hasRenderTargetTextures",
        "type": "Boolean"
      },
      {
        "comment": "In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\nYou can try switching to logarithmic depth.",
        "name": "useLogarithmicDepth",
        "type": "Boolean"
      }
    ]
  },
  "StereoscopicArcRotateCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "alpha",
        "type": "Number"
      },
      {
        "name": "beta",
        "type": "Number"
      },
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "isStereoscopicSideBySide",
        "type": "Boolean"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)",
    "family": "cameras",
    "name": "StereoscopicArcRotateCamera",
    "props": []
  },
  "StereoscopicFreeCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "isStereoscopicSideBySide",
        "type": "Boolean"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate stereoscopic rendering (based on FreeCamera)",
    "family": "cameras",
    "name": "StereoscopicFreeCamera",
    "props": []
  },
  "StereoscopicGamepadCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "isStereoscopicSideBySide",
        "type": "Boolean"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate stereoscopic rendering (based on GamepadCamera)",
    "family": "cameras",
    "name": "StereoscopicGamepadCamera",
    "props": []
  },
  "StereoscopicUniversalCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "interaxialDistance",
        "type": "Number"
      },
      {
        "name": "isStereoscopicSideBySide",
        "type": "Boolean"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Camera used to simulate stereoscopic rendering (based on UniversalCamera)",
    "family": "cameras",
    "name": "StereoscopicUniversalCamera",
    "props": []
  },
  "TargetCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "setActiveOnSceneIfNoneActive",
        "type": "Boolean"
      }
    ],
    "comment": "A target camera takes a mesh or position as a target and continues to look at it while it moves.\nThis is the base of the follow, arc rotate cameras and Free camera",
    "family": "cameras",
    "name": "TargetCamera",
    "props": [
      {
        "comment": "Define the current direction the camera is moving to",
        "name": "cameraDirection",
        "type": "Vector3"
      },
      {
        "comment": "Define the current rotation the camera is rotating to",
        "name": "cameraRotation",
        "type": "Vector2"
      },
      {
        "comment": "Define the current rotation of the camera",
        "name": "rotation",
        "type": "Vector3"
      },
      {
        "comment": "Define the current rotation of the camera as a quaternion to prevent Gimbal lock",
        "name": "rotationQuaternion",
        "type": "Quaternion"
      },
      {
        "comment": "Define the current speed of the camera",
        "name": "speed",
        "type": "Number"
      },
      {
        "comment": "Add cconstraint to the camera to prevent it to move freely in all directions and\naround all axis.",
        "name": "noRotationConstraint",
        "type": "Boolean"
      },
      {
        "comment": "Define the current target of the camera as an object or a position.",
        "name": "lockedTarget",
        "type": "Any"
      }
    ]
  },
  "Texture": {
    "args": [
      {
        "name": "url",
        "type": "Nullable"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "noMipmap",
        "type": "Boolean"
      },
      {
        "name": "invertY",
        "type": "Boolean"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "onLoad",
        "type": "Nullable"
      },
      {
        "name": "onError",
        "type": "Nullable"
      },
      {
        "name": "buffer",
        "type": "Nullable"
      },
      {
        "name": "deleteBuffer",
        "type": "Boolean"
      },
      {
        "name": "format",
        "type": "Number"
      }
    ],
    "comment": "This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.",
    "family": "materials",
    "name": "Texture",
    "props": [
      {
        "comment": "Define the url of the texture.",
        "name": "url",
        "type": "Nullable"
      },
      {
        "comment": "Define an offset on the texture to offset the u coordinates of the UVs",
        "name": "uOffset",
        "type": "Number"
      },
      {
        "comment": "Define an offset on the texture to offset the v coordinates of the UVs",
        "name": "vOffset",
        "type": "Number"
      },
      {
        "comment": "Define an offset on the texture to scale the u coordinates of the UVs",
        "name": "uScale",
        "type": "Number"
      },
      {
        "comment": "Define an offset on the texture to scale the v coordinates of the UVs",
        "name": "vScale",
        "type": "Number"
      },
      {
        "comment": "Define an offset on the texture to rotate around the u coordinates of the UVs",
        "name": "uAng",
        "type": "Number"
      },
      {
        "comment": "Define an offset on the texture to rotate around the v coordinates of the UVs",
        "name": "vAng",
        "type": "Number"
      },
      {
        "comment": "Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)",
        "name": "wAng",
        "type": "Number"
      },
      {
        "comment": "Defines the center of rotation (U)",
        "name": "uRotationCenter",
        "type": "Number"
      },
      {
        "comment": "Defines the center of rotation (V)",
        "name": "vRotationCenter",
        "type": "Number"
      },
      {
        "comment": "Defines the center of rotation (W)",
        "name": "wRotationCenter",
        "type": "Number"
      },
      {
        "comment": "Are mip maps generated for this texture or not.",
        "name": "noMipmap",
        "type": "Boolean"
      },
      {
        "comment": "Observable triggered once the texture has been loaded.",
        "name": "onLoadObservable",
        "type": "Observable"
      },
      {
        "comment": "Is the texture preventing material to render while loading.\nIf false, a default texture will be used instead of the loading one during the preparation step.",
        "name": "isBlocking",
        "type": "Boolean"
      },
      {
        "comment": "Get the current sampling mode associated with the texture.",
        "name": "samplingMode",
        "type": "Number"
      }
    ]
  },
  "TextureAssetTask": {
    "args": [
      {
        "comment": "Defines the name of the task",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Defines the location of the file to load",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Defines if mipmap should not be generated (default is false)",
        "name": "noMipmap",
        "type": "Union"
      },
      {
        "comment": "Defines if texture must be inverted on Y axis (default is false)",
        "name": "invertY",
        "type": "Union"
      },
      {
        "comment": "Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)",
        "name": "samplingMode",
        "type": "Number"
      }
    ],
    "comment": "Define a task used by AssetsManager to load 2D textures",
    "family": "materials",
    "name": "TextureAssetTask",
    "props": [
      {
        "comment": "Defines the name of the task",
        "name": "name",
        "type": "string"
      },
      {
        "comment": "Defines the location of the file to load",
        "name": "url",
        "type": "String"
      },
      {
        "comment": "Defines if mipmap should not be generated (default is false)",
        "name": "noMipmap",
        "type": "Union"
      },
      {
        "comment": "Defines if texture must be inverted on Y axis (default is false)",
        "name": "invertY",
        "type": "Union"
      },
      {
        "comment": "Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)",
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "comment": "Gets the loaded texture",
        "name": "texture",
        "type": "Texture"
      },
      {
        "comment": "Callback called when the task is successful",
        "name": "onSuccess",
        "type": "Function"
      },
      {
        "comment": "Callback called when the task is successful",
        "name": "onError",
        "type": "Function"
      }
    ]
  },
  "TextureOptimization": {
    "args": [
      {
        "comment": "Defines the priority of this optimization (0 by default which means first in the list)",
        "name": "priority",
        "type": "Number"
      },
      {
        "comment": "Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter",
        "name": "maximumSize",
        "type": "Number"
      },
      {
        "comment": "Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.",
        "name": "step",
        "type": "Number"
      }
    ],
    "comment": "Defines an optimization used to reduce the size of render target textures",
    "family": "materials",
    "name": "TextureOptimization",
    "props": [
      {
        "comment": "Defines the priority of this optimization (0 by default which means first in the list)",
        "name": "priority",
        "type": "Number"
      },
      {
        "comment": "Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter",
        "name": "maximumSize",
        "type": "Number"
      },
      {
        "comment": "Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.",
        "name": "step",
        "type": "Number"
      }
    ]
  },
  "TiledGround": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a tiled ground mesh\n* The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\n* The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\n* The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\n* The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.",
    "family": "meshes",
    "name": "CreateTiledGround",
    "options": [
      {
        "name": "xmin",
        "type": "Number"
      },
      {
        "name": "zmin",
        "type": "Number"
      },
      {
        "name": "xmax",
        "type": "Number"
      },
      {
        "name": "zmax",
        "type": "Number"
      },
      {
        "name": "subdivisions",
        "type": "Literal"
      },
      {
        "name": "precision",
        "type": "Literal"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "Torus": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a torus mesh\n* The parameter `diameter` sets the diameter size (float) of the torus (default 1)\n* The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\n* The parameter `tessellation` sets the number of torus sides (postive integer, default 16)\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.",
    "family": "meshes",
    "name": "CreateTorus",
    "options": [
      {
        "name": "diameter",
        "type": "Number"
      },
      {
        "name": "thickness",
        "type": "Number"
      },
      {
        "name": "tessellation",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "TorusKnot": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a torus knot mesh\n* The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\n* The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\n* The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\n* The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.",
    "family": "meshes",
    "name": "CreateTorusKnot",
    "options": [
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "tube",
        "type": "Number"
      },
      {
        "name": "radialSegments",
        "type": "Number"
      },
      {
        "name": "tubularSegments",
        "type": "Number"
      },
      {
        "name": "p",
        "type": "Number"
      },
      {
        "name": "q",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "TouchCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "This represents a FPS type of camera controlled by touch.\nThis is like a universal camera minus the Gamepad controls.",
    "family": "cameras",
    "name": "TouchCamera",
    "props": [
      {
        "comment": "Defines the touch sensibility for rotation.\nThe higher the faster.",
        "name": "touchAngularSensibility",
        "type": "Number"
      },
      {
        "comment": "Defines the touch sensibility for move.\nThe higher the faster.",
        "name": "touchMoveSensibility",
        "type": "Number"
      }
    ]
  },
  "Tube": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Creates a tube mesh.\nThe tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\n* The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\n* The parameter `radius` (positive float, default 1) sets the tube radius size\n* The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\n* The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`\n* This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\n* The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\n* The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n* The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube\n* You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n* If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n* The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n* The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created",
    "family": "meshes",
    "name": "CreateTube",
    "options": [
      {
        "name": "path",
        "type": [
          "Vector3"
        ]
      },
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "tessellation",
        "type": "Number"
      },
      {
        "name": "radiusFunction",
        "type": "Literal"
      },
      {
        "name": "cap",
        "type": "Number"
      },
      {
        "name": "arc",
        "type": "Number"
      },
      {
        "name": "updatable",
        "type": "Boolean"
      },
      {
        "name": "sideOrientation",
        "type": "Number"
      },
      {
        "name": "frontUVs",
        "type": "Vector4"
      },
      {
        "name": "backUVs",
        "type": "Vector4"
      },
      {
        "name": "instance",
        "type": "Mesh"
      },
      {
        "name": "invertUV",
        "type": "Boolean"
      }
    ],
    "props": [],
    "return": "Mesh"
  },
  "UniversalCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\nwhich still works and will still be found in many Playgrounds.",
    "family": "cameras",
    "name": "UniversalCamera",
    "props": [
      {
        "comment": "Defines the gamepad rotation sensiblity.\nThis is the threshold from when rotation starts to be accounted for to prevent jittering.",
        "name": "gamepadAngularSensibility",
        "type": "Number"
      },
      {
        "comment": "Defines the gamepad move sensiblity.\nThis is the threshold from when moving starts to be accounted for for to prevent jittering.",
        "name": "gamepadMoveSensibility",
        "type": "Number"
      }
    ]
  },
  "VRCameraMetrics": {
    "args": [],
    "comment": "This represents all the required metrics to create a VR camera.",
    "family": "cameras",
    "name": "VRCameraMetrics",
    "props": [
      {
        "comment": "Define the horizontal resolution off the screen.",
        "name": "hResolution",
        "type": "Number"
      },
      {
        "comment": "Define the vertical resolution off the screen.",
        "name": "vResolution",
        "type": "Number"
      },
      {
        "comment": "Define the horizontal screen size.",
        "name": "hScreenSize",
        "type": "Number"
      },
      {
        "comment": "Define the vertical screen size.",
        "name": "vScreenSize",
        "type": "Number"
      },
      {
        "comment": "Define the vertical screen center position.",
        "name": "vScreenCenter",
        "type": "Number"
      },
      {
        "comment": "Define the distance of the eyes to the screen.",
        "name": "eyeToScreenDistance",
        "type": "Number"
      },
      {
        "comment": "Define the distance between both lenses",
        "name": "lensSeparationDistance",
        "type": "Number"
      },
      {
        "comment": "Define the distance between both viewer's eyes.",
        "name": "interpupillaryDistance",
        "type": "Number"
      },
      {
        "comment": "Define the distortion factor of the VR postprocess.\nPlease, touch with care.",
        "name": "distortionK",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Define the chromatic aberration correction factors for the VR post process.",
        "name": "chromaAbCorrection",
        "type": [
          "Number"
        ]
      },
      {
        "comment": "Define the scale factor of the post process.\nThe smaller the better but the slower.",
        "name": "postProcessScaleFactor",
        "type": "Number"
      },
      {
        "comment": "Define an offset for the lens center.",
        "name": "lensCenterOffset",
        "type": "Number"
      },
      {
        "comment": "Define if the current vr camera should compensate the distortion of the lense or not.",
        "name": "compensateDistortion",
        "type": "Boolean"
      },
      {
        "comment": "Gets the rendering aspect ratio based on the provided resolutions.",
        "name": "aspectRatio",
        "type": "Number"
      },
      {
        "comment": "Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.",
        "name": "aspectRatioFov",
        "type": "Number"
      },
      {
        "name": "leftHMatrix",
        "type": "Matrix"
      },
      {
        "name": "rightHMatrix",
        "type": "Matrix"
      },
      {
        "name": "leftPreViewMatrix",
        "type": "Matrix"
      },
      {
        "name": "rightPreViewMatrix",
        "type": "Matrix"
      }
    ]
  },
  "VRDeviceOrientationArcRotateCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "alpha",
        "type": "Number"
      },
      {
        "name": "beta",
        "type": "Number"
      },
      {
        "name": "radius",
        "type": "Number"
      },
      {
        "name": "target",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "compensateDistortion",
        "type": "Boolean"
      },
      {
        "name": "vrCameraMetrics",
        "type": "VRCameraMetrics"
      }
    ],
    "comment": "Camera used to simulate VR rendering (based on ArcRotateCamera)",
    "family": "cameras",
    "name": "VRDeviceOrientationArcRotateCamera",
    "props": []
  },
  "VRDeviceOrientationFreeCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "compensateDistortion",
        "type": "Boolean"
      },
      {
        "name": "vrCameraMetrics",
        "type": "VRCameraMetrics"
      }
    ],
    "comment": "Camera used to simulate VR rendering (based on FreeCamera)",
    "family": "cameras",
    "name": "VRDeviceOrientationFreeCamera",
    "props": []
  },
  "VRDeviceOrientationGamepadCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "compensateDistortion",
        "type": "Boolean"
      },
      {
        "name": "vrCameraMetrics",
        "type": "VRCameraMetrics"
      }
    ],
    "comment": "Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)",
    "family": "cameras",
    "name": "VRDeviceOrientationGamepadCamera",
    "props": []
  },
  "VideoTexture": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "src",
        "type": "Union"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "generateMipMaps",
        "type": "Boolean"
      },
      {
        "name": "invertY",
        "type": "Boolean"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "settings",
        "type": "VideoTextureSettings"
      }
    ],
    "comment": "If you want to display a video in your scene, this is the special texture for that.\nThis special texture works similar to other textures, with the exception of a few parameters.",
    "family": "materials",
    "name": "VideoTexture",
    "props": [
      {
        "comment": "Tells whether textures will be updated automatically or user is required to call `updateTexture` manually",
        "name": "autoUpdateTexture",
        "type": "Boolean"
      },
      {
        "comment": "The video instance used by the texture internally",
        "name": "video",
        "type": "HTMLVideoElement"
      },
      {
        "comment": "Event triggerd when a dom action is required by the user to play the video.\nThis happens due to recent changes in browser policies preventing video to auto start.",
        "name": "onUserActionRequestedObservable",
        "type": "Observable"
      },
      {
        "name": "reset"
      }
    ]
  },
  "VirtualJoysticksCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "This represents a free type of camera. It can be usefull in First Person Shooter game for instance.\nIt is identical to the Free Camera and simply adds by default a virtual joystick.\nVirtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.",
    "family": "cameras",
    "name": "VirtualJoysticksCamera",
    "props": []
  },
  "VolumetricLightScatteringPostProcess": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "ratio",
        "type": "Any"
      },
      {
        "name": "camera",
        "type": "Camera"
      },
      {
        "name": "mesh",
        "type": "Mesh"
      },
      {
        "name": "samples",
        "type": "Number"
      },
      {
        "name": "samplingMode",
        "type": "Number"
      },
      {
        "name": "engine",
        "type": "Engine"
      },
      {
        "name": "reusable",
        "type": "Boolean"
      },
      {
        "name": "scene",
        "type": "Scene"
      }
    ],
    "comment": "Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html",
    "family": "lights",
    "name": "VolumetricLightScatteringPostProcess",
    "props": [
      {
        "comment": "If not undefined, the mesh position is computed from the attached node position",
        "name": "attachedNode",
        "type": "Literal"
      },
      {
        "comment": "Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"",
        "name": "customMeshPosition",
        "type": "Vector3"
      },
      {
        "comment": "Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)",
        "name": "useCustomMeshPosition",
        "type": "Boolean"
      },
      {
        "comment": "If the post-process should inverse the light scattering direction",
        "name": "invert",
        "type": "Boolean"
      },
      {
        "comment": "The internal mesh used by the post-process",
        "name": "mesh",
        "type": "Mesh"
      },
      {
        "name": "useDiffuseColor",
        "type": "Boolean"
      },
      {
        "comment": "Array containing the excluded meshes not rendered in the internal pass",
        "name": "excludedMeshes",
        "type": [
          "AbstractMesh"
        ]
      },
      {
        "comment": "Controls the overall intensity of the post-process",
        "name": "exposure",
        "type": "Number"
      },
      {
        "comment": "Dissipates each sample's contribution in range [0, 1]",
        "name": "decay",
        "type": "Number"
      },
      {
        "comment": "Controls the overall intensity of each sample",
        "name": "weight",
        "type": "Number"
      },
      {
        "comment": "Controls the density of each sample",
        "name": "density",
        "type": "Number"
      }
    ]
  },
  "WebVRFreeCamera": {
    "args": [
      {
        "name": "name",
        "type": "string"
      },
      {
        "name": "position",
        "type": "Vector3"
      },
      {
        "name": "scene",
        "type": "Scene"
      },
      {
        "name": "webVROptions",
        "type": "WebVROptions"
      }
    ],
    "comment": "This represents a WebVR camera.\nThe WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.",
    "family": "cameras",
    "name": "WebVRFreeCamera",
    "props": [
      {
        "name": "webVROptions"
      },
      {
        "comment": "The rawPose of the vrDevice.",
        "name": "rawPose",
        "type": "Nullable"
      },
      {
        "comment": "Represents device position in babylon space.",
        "name": "devicePosition",
        "type": "Vector3"
      },
      {
        "comment": "Represents device rotation in babylon space.",
        "name": "deviceRotationQuaternion",
        "type": "Quaternion"
      },
      {
        "comment": "The scale of the device to be used when translating from device space to babylon space.",
        "name": "deviceScaleFactor",
        "type": "Number"
      },
      {
        "comment": "References to the webVR controllers for the vrDevice.",
        "name": "controllers",
        "type": [
          null
        ]
      },
      {
        "comment": "Emits an event when a controller is attached.",
        "name": "onControllersAttachedObservable",
        "type": "Observable"
      },
      {
        "comment": "Emits an event when a controller's mesh has been loaded;",
        "name": "onControllerMeshLoadedObservable",
        "type": "Observable"
      },
      {
        "comment": "Emits an event when the HMD's pose has been updated.",
        "name": "onPoseUpdatedFromDeviceObservable",
        "type": "Observable"
      },
      {
        "comment": "If the rig cameras be used as parent instead of this camera.",
        "name": "rigParenting",
        "type": "Boolean"
      },
      {
        "comment": "The controller corrisponding to the users left hand.",
        "name": "leftController",
        "type": "Nullable"
      },
      {
        "comment": "The controller corrisponding to the users right hand.",
        "name": "rightController",
        "type": "Nullable"
      },
      {
        "name": "updateCacheCalled"
      }
    ]
  }
}